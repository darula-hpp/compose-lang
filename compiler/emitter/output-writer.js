/**
 * Output Writer
 * Writes generated code files to disk
 */

import { mkdirSync, writeFileSync, existsSync } from 'fs';
import { dirname, join } from 'path';

/**
 * Normalize file path by removing common output directory prefixes
 * @param {string} filePath - Generated file path
 * @param {string} baseOutputDir - Base output directory
 * @returns {string} - Normalized path
 */
function normalizePath(filePath, baseOutputDir) {
    // Remove leading ./ or /
    let normalized = filePath.replace(/^\.?\//, '');

    // Extract directory parts from baseOutputDir
    const baseDirParts = baseOutputDir.replace(/^\.?\//, '').split('/');

    // Try to find and remove common prefixes
    for (let i = baseDirParts.length; i > 0; i--) {
        const prefix = baseDirParts.slice(-i).join('/') + '/';
        if (normalized.startsWith(prefix)) {
            normalized = normalized.substring(prefix.length);
            break;
        }
    }

    return normalized;
}

export class OutputWriter {
    constructor(baseOutputDir) {
        this.baseOutputDir = baseOutputDir;
    }

    /**
     * Write all generated files to disk
     * @param {Array} files - Array of file objects {path, content, type}
     * @returns {object} - Write summary
     */
    write(files) {
        const written = [];
        const errors = [];

        for (const file of files) {
            try {
                // Normalize the path before writing
                const normalizedPath = normalizePath(file.path, this.baseOutputDir);
                this.writeFile({ ...file, path: normalizedPath });
                written.push(normalizedPath);
            } catch (error) {
                errors.push({
                    path: file.path,
                    error: error.message
                });
            }
        }

        return {
            success: errors.length === 0,
            written,
            errors
        };
    }

    /**
     * Write a single file
     * @param {object} file - File object {path, content, type}
     */
    writeFile(file) {
        const fullPath = join(this.baseOutputDir, file.path);
        const dir = dirname(fullPath);

        // Create directory if it doesn't exist
        if (!existsSync(dir)) {
            mkdirSync(dir, { recursive: true });
        }

        // Write file
        writeFileSync(fullPath, file.content, 'utf8');
    }

    /**
     * Create package.json for generated project
     * @param {object} target - Target configuration
     * @param {string} projectName - Project name
     */
    writePackageJson(target, projectName = 'compose-generated-app') {
        const packageJson = {
            name: projectName,
            version: '1.0.0',
            type: target.moduleSystem || 'module',
            scripts: this.generateScripts(target),
            dependencies: this.generateDependencies(target),
            devDependencies: this.generateDevDependencies(target)
        };

        const content = JSON.stringify(packageJson, null, 2);
        this.writeFile({
            path: 'package.json',
            content,
            type: 'config'
        });
    }

    /**
     * Generate npm scripts based on target
     */
    generateScripts(target) {
        if (target.framework === 'vite') {
            return {
                dev: 'vite',
                build: 'vite build',
                preview: 'vite preview'
            };
        }

        if (target.type === 'node') {
            return {
                start: 'node index.js',
                dev: 'nodemon index.js'
            };
        }

        return {
            start: 'node index.js'
        };
    }

    /**
     * Generate dependencies list
     */
    generateDependencies(target) {
        const deps = {};

        if (target.dependencies) {
            target.dependencies.forEach(dep => {
                deps[dep] = 'latest';
            });
        }

        return deps;
    }

    /**
     * Generate dev dependencies list
     */
    generateDevDependencies(target) {
        const devDeps = {};

        if (target.framework === 'vite') {
            devDeps['vite'] = 'latest';
            devDeps['@vitejs/plugin-react'] = 'latest';
        }

        if (target.type === 'node') {
            devDeps['nodemon'] = 'latest';
        }

        return devDeps;
    }

    /**
     * Write README.md
     * @param {string} projectName - Project name
     * @param {object} target - Target configuration
     */
    writeReadme(projectName, target) {
        const content = `# ${projectName}

Generated by Compose Language Compiler

## Stack

- Type: ${target.type}
- Framework: ${target.framework || 'none'}
- Language: ${target.language}

## Setup

\`\`\`bash
npm install
\`\`\`

## Development

\`\`\`bash
npm run dev
\`\`\`

## Build

\`\`\`bash
npm run build
\`\`\`

---

Generated from Compose source files.
`;

        this.writeFile({
            path: 'README.md',
            content,
            type: 'docs'
        });
    }
}

/**
 * Write generated code to disk
 * @param {Array} files - Generated files
 * @param {string} outputDir - Output directory
 * @param {object} target - Target configuration
 * @returns {object} - Write result
 */
export function writeOutput(files, outputDir, target) {
    const writer = new OutputWriter(outputDir);
    const result = writer.write(files);

    // Write package.json and README
    writer.writePackageJson(target);
    writer.writeReadme('Compose Generated App', target);

    return result;
}
