{
  "74b3d3b04794134fddb709c6640c77a6481ecd60faeb5a9e5514792e985467cf": "import React from 'react';\n\n/**\n * Home Page Component\n *\n * This component serves as the main entry point for the todo list application.\n * It displays a welcome message and acts as a container for future todo list features.\n *\n * @returns {JSX.Element} The Home page component.\n */\nfunction Home() {\n  // State can be added here for managing data specific to the Home page,\n  // e.g., a list of todos, loading states, etc.\n  // const [todos, setTodos] = React.useState([]);\n  // const [isLoading, setIsLoading] = React.useState(true);\n\n  // Effects can be used here for data fetching or side effects.\n  // React.useEffect(() => {\n  //   // Example: Fetch todos when the component mounts\n  //   const fetchTodos = async () => {\n  //     try {\n  //       // Simulate API call\n  //       // const response = await fetch('/api/todos');\n  //       // const data = await response.json();\n  //       // setTodos(data);\n  //       console.log('Fetching todos...');\n  //       setTimeout(() => {\n  //         // setTodos([{ id: 1, text: 'Learn React', completed: false }]);\n  //         // setIsLoading(false);\n  //         console.log('Todos fetched (simulated).');\n  //       }, 1000);\n  //     } catch (error) {\n  //       console.error('Failed to fetch todos:', error);\n  //       // setIsLoading(false);\n  //       // Implement proper error display to the user\n  //     }\n  //   };\n  //   fetchTodos();\n  // }, []); // Empty dependency array ensures this runs only once on mount\n\n  return (\n    <div className=\"home-page\">\n      {/* Page Header */}\n      <header className=\"home-header\">\n        <h1>Welcome to Your Todo List!</h1>\n        <p>This is your main todo list page where you can manage all your tasks.</p>\n      </header>\n\n      {/* Main Content Area for Todo List */}\n      <main className=\"home-content\">\n        {/*\n          * This section will eventually house the main todo list functionality.\n          * For now, it serves as a placeholder.\n          *\n          * Future features might include:\n          * - A form to add new todos\n          * - A list component to display existing todos\n          * - Filtering and sorting options\n          * - Individual todo item components with edit/delete functionality\n          */}\n        <section className=\"todo-list-section\">\n          <h2>Your Tasks</h2>\n          {/* Example of conditional rendering for loading state */}\n          {/* {isLoading ? (\n            <p>Loading todos...</p>\n          ) : todos.length === 0 ? (\n            <p>No todos yet! Start by adding a new task.</p>\n          ) : (\n            <ul>\n              {todos.map(todo => (\n                <li key={todo.id}>{todo.text}</li>\n              ))}\n            </ul>\n          )} */}\n          <p>This is where your list of todos will appear.</p>\n          <p>Stay organized and productive!</p>\n        </section>\n\n        {/* Optional: Add a quick action section */}\n        <section className=\"quick-actions\">\n          <h3>Quick Actions</h3>\n          <button onClick={() => console.log('Add new todo clicked!')}>Add New Todo</button>\n          {/* More buttons or links for common actions */}\n        </section>\n      </main>\n\n      {/* Page Footer (optional) */}\n      <footer className=\"home-footer\">\n        <p>&copy; {new Date().getFullYear()} My Todo App</p>\n      </footer>\n    </div>\n  );\n}\n\nexport default Home;",
  "b98cde00bbf2f3d2bcc624048a1c07fbeeedcf2903904584e9f5a44ac9b7fe72": "import React from 'react';\nimport PropTypes from 'prop-types';\n\nconst TodoItem = ({ todo, onToggleComplete, onDelete }) => {\n  // Destructure properties from the todo object for easier access.\n  const { id, text, completed } = todo;\n\n  /**\n   * Handles the change event for the checkbox.\n   * Calls the onToggleComplete prop function with the todo's ID and its new completion status.\n   */\n  const handleToggle = () => {\n    // Invert the current completed status and pass it to the parent handler.\n    onToggleComplete(id, !completed);\n  };\n\n  /**\n   * Handles the click event for the delete button.\n   * Calls the onDelete prop function with the todo's ID.\n   */\n  const handleDeleteClick = () => {\n    onDelete(id);\n  };\n\n  return (\n    <li className={`todo-item ${completed ? 'completed' : ''}`}>\n      <input\n        type=\"checkbox\"\n        checked={completed}\n        onChange={handleToggle}\n        aria-label={`Mark \"${text}\" as ${completed ? 'incomplete' : 'complete'}`}\n      />\n      <span className=\"todo-text\">{text}</span>\n      <button\n        onClick={handleDeleteClick}\n        className=\"delete-button\"\n        aria-label={`Delete \"${text}\"`}\n      >\n        Delete\n      </button>\n    </li>\n  );\n};\n\n// Prop validation to ensure the component receives the correct data types.\nTodoItem.propTypes = {\n  // The 'todo' object containing details about a single todo item.\n  todo: PropTypes.shape({\n    id: PropTypes.string.isRequired, // Unique identifier for the todo.\n    text: PropTypes.string.isRequired, // The description of the todo.\n    completed: PropTypes.bool.isRequired, // The completion status of the todo.\n  }).isRequired,\n  // Function to call when the todo's completion status changes.\n  // It receives the todo's ID and the new completion status.\n  onToggleComplete: PropTypes.func.isRequired,\n  // Function to call when the todo is to be deleted.\n  // It receives the todo's ID.\n  onDelete: PropTypes.func.isRequired,\n};\n\nexport default TodoItem;",
  "91fe248d4fd996fdd3130cd70ab41849994cb75aa3e620a2fcfc56412da13f1d": "import React, { useState } from 'react';\nimport PropTypes from 'prop-types';\n\n/**\n * TodoForm Component\n * A functional component that provides a form to add new todo items.\n * It manages its own input state and handles form submission.\n */\nfunction TodoForm() {\n  // State to hold the current value of the todo input field\n  const [todoText, setTodoText] = useState('');\n\n  /**\n   * Handles changes to the input field.\n   * Updates the component's state with the new input value.\n   * @param {Object} event - The change event object from the input field.\n   */\n  const handleChange = (event) => {\n    setTodoText(event.target.value);\n  };\n\n  /**\n   * Handles the form submission.\n   * Prevents the default form submission behavior, processes the todo text,\n   * and then clears the input field.\n   * In a real application, this would typically dispatch an action to add the todo\n   * to a global state manager or send it to an API.\n   * @param {Object} event - The submit event object from the form.\n   */\n  const handleSubmit = (event) => {\n    event.preventDefault(); // Prevent default browser form submission\n\n    // Trim whitespace from the input text\n    const trimmedTodoText = todoText.trim();\n\n    // Only proceed if the input text is not empty\n    if (trimmedTodoText) {\n      // --- Placeholder for actual todo creation logic ---\n      // In a real application, you would typically pass this `trimmedTodoText`\n      // up to a parent component via a prop function, or dispatch an action\n      // to a state management system (e.g., Redux, Context API).\n      console.log('Adding new todo:', trimmedTodoText);\n\n      // Clear the input field after successful submission\n      setTodoText('');\n    } else {\n      // Optional: Provide user feedback if the input is empty\n      console.warn('Todo text cannot be empty.');\n      // alert('Please enter a todo item!'); // Or display a more subtle message\n    }\n  };\n\n  return (\n    // The form element handles the submission of the new todo\n    <form className=\"todo-form\" onSubmit={handleSubmit}>\n      <input\n        type=\"text\"\n        className=\"todo-input\"\n        placeholder=\"Add a new todo...\"\n        value={todoText} // Controlled component: input value is tied to state\n        onChange={handleChange} // Update state on every input change\n        aria-label=\"New todo item\" // Accessibility label\n      />\n      <button type=\"submit\" className=\"todo-button\">\n        Add Todo\n      </button>\n    </form>\n  );\n}\n\n// PropTypes for TodoForm. Since there are no props, it's an empty object.\n// This is included for completeness as per the requirement for prop validation.\nTodoForm.propTypes = {};\n\nexport default TodoForm;",
  "15a11a160bec268d806f27237b655e45252fa18a8f0ff3a1a4b9783cd88451b6": "const express = require('express');\nconst router = express.Router();\n\n/**\n * @typedef {Object} Todo\n * @property {string} id - Unique identifier for the todo.\n * @property {string} title - The title of the todo.\n * @property {boolean} completed - The completion status of the todo.\n */\n\n/**\n * Mock database service for demonstration purposes.\n * In a real application, this would interact with a persistent database\n * (e.g., MongoDB with Mongoose, PostgreSQL with Sequelize/Knex, etc.).\n */\nconst todoService = {\n    /**\n     * Simulates fetching all todos from a database.\n     * @returns {Promise<Array<Todo>>} A promise that resolves to an array of todo objects.\n     */\n    async findAll() {\n        return new Promise(resolve => {\n            // Simulate a network/database delay\n            setTimeout(() => {\n                const todos = [\n                    { id: '1', title: 'Learn Node.js', completed: false },\n                    { id: '2', title: 'Build an Express API', completed: true },\n                    { id: '3', title: 'Deploy to production', completed: false },\n                    { id: '4', title: 'Write documentation', completed: false },\n                ];\n                resolve(todos);\n            }, 150); // Simulate a small delay\n        });\n    }\n};\n\n/**\n * @route GET /\n * @description Fetch all todos from the database.\n * @access Public\n *\n * This endpoint retrieves a list of all available todo items.\n * It follows REST API best practices by using the GET method for data retrieval\n * and returning a 200 OK status with a JSON array.\n * If no todos are found, it returns an empty array, which is standard for collection endpoints.\n */\nrouter.get('/', async (req, res, next) => {\n    try {\n        // Input Validation:\n        // For a simple 'fetch all' endpoint, there are typically no path or body parameters\n        // to validate. If query parameters for filtering, sorting, or pagination were\n        // expected (e.g., /todos?limit=10&offset=0), validation middleware (like Joi or express-validator)\n        // would be used here to ensure they are valid.\n        // Example:\n        // const { error } = someValidationSchema.validate(req.query);\n        // if (error) {\n        //     return res.status(400).json({ message: error.details[0].message });\n        // }\n\n        // Fetch all todos using the mock service\n        const todos = await todoService.findAll();\n\n        // Respond with the fetched todos.\n        // If no todos are found, an empty array is returned with a 200 OK status,\n        // which is a standard and expected behavior for collection endpoints.\n        res.status(200).json(todos);\n    } catch (error) {\n        // Error Handling:\n        // Log the error for debugging purposes. In a production environment,\n        // this would typically go to a centralized logging service (e.g., Winston, Pino).\n        console.error('Error fetching todos:', error.message, error.stack);\n\n        // Pass the error to the Express error handling middleware.\n        // This allows a centralized error handler (defined in app.js or a dedicated file)\n        // to catch and process the error, sending a consistent error response to the client\n        // (e.g., 500 Internal Server Error).\n        next(error);\n    }\n});\n\nmodule.exports = router;",
  "489e9ae9637c51e0838b5802216bd110b4bf27e4b79b6238b6ec3117db40fceb": "const express = require('express');\nconst router = express.Router();\n\n// In a real application, this would be a database model or service.\n// We'll use a simple in-memory array for demonstration purposes.\nconst todos = [];\nlet nextId = 1; // Simple ID generator for mock data\n\n/**\n * @route POST /todos\n * @description Create a new todo item\n * @access Public\n * @body {string} title - The title of the todo item (required)\n * @body {string} [description] - An optional description for the todo item\n * @body {boolean} [completed=false] - The completion status of the todo item\n */\nrouter.post('/todos', (req, res) => {\n    try {\n        // Destructure and sanitize input from the request body\n        const { title, description, completed } = req.body;\n\n        // 1. Input Validation\n        // Ensure title is provided, is a string, and is not empty\n        if (!title || typeof title !== 'string' || title.trim().length === 0) {\n            return res.status(400).json({ message: 'Title is required and must be a non-empty string.' });\n        }\n\n        // Validate description if provided\n        if (description !== undefined && typeof description !== 'string') {\n            return res.status(400).json({ message: 'Description must be a string if provided.' });\n        }\n\n        // Validate completed status if provided\n        if (completed !== undefined && typeof completed !== 'boolean') {\n            return res.status(400).json({ message: 'Completed status must be a boolean if provided.' });\n        }\n\n        // 2. Business Logic: Create the new todo item\n        const newTodo = {\n            id: nextId++, // Assign a unique ID\n            title: title.trim(),\n            description: description ? description.trim() : '', // Default to empty string if not provided\n            completed: completed || false, // Default to false if not provided\n            createdAt: new Date().toISOString() // Add a creation timestamp\n        };\n\n        // In a production application, you would interact with a database here\n        // e.g., `await TodoModel.create(newTodo);`\n        todos.push(newTodo); // Add to our mock data store\n\n        // 3. Respond with the newly created resource\n        // Use 201 Created status code for successful resource creation\n        res.status(201).json(newTodo);\n\n    } catch (error) {\n        // 4. Error Handling\n        // Log the error for debugging purposes. In a real app, use a dedicated logger.\n        console.error('Error creating todo item:', error);\n\n        // Respond with a 500 Internal Server Error for unexpected issues\n        res.status(500).json({ message: 'An unexpected error occurred while creating the todo item.' });\n    }\n});\n\nmodule.exports = router;",
  "c2ec3b17944ac83e0f1dc18eadec237ba5757f05cea5147768217b1d48d58b18": "const express = require('express');\nconst router = express.Router();\n\n// Mock database for demonstration purposes\n// In a real application, this would interact with a database (e.g., MongoDB, PostgreSQL)\nlet todos = [\n    { id: 1, title: 'Learn Node.js', completed: false },\n    { id: 2, title: 'Build an Express API', completed: true },\n    { id: 3, title: 'Deploy to production', completed: false }\n];\n\n/**\n * @swagger\n * /todos/{id}/toggle:\n *   patch:\n *     summary: Toggle todo completed status\n *     description: Toggles the 'completed' status of a specific todo item by its ID.\n *     parameters:\n *       - in: path\n *         name: id\n *         schema:\n *           type: integer\n *         required: true\n *         description: Numeric ID of the todo item to toggle.\n *     responses:\n *       200:\n *         description: Todo status toggled successfully.\n *         content:\n *           application/json:\n *             schema:\n *               type: object\n *               properties:\n *                 message:\n *                   type: string\n *                   example: Todo status toggled successfully.\n *                 todo:\n *                   type: object\n *                   properties:\n *                     id: { type: integer, example: 1 }\n *                     title: { type: string, example: \"Learn Node.js\" }\n *                     completed: { type: boolean, example: true }\n *       400:\n *         description: Invalid todo ID provided.\n *         content:\n *           application/json:\n *             schema:\n *               type: object\n *               properties:\n *                 message:\n *                   type: string\n *                   example: Invalid todo ID provided.\n *       404:\n *         description: Todo not found.\n *         content:\n *           application/json:\n *             schema:\n *               type: object\n *               properties:\n *                 message:\n *                   type: string\n *                   example: Todo with ID 999 not found.\n *       500:\n *         description: An unexpected error occurred.\n *         content:\n *           application/json:\n *             schema:\n *               type: object\n *               properties:\n *                 message:\n *                   type: string\n *                   example: An unexpected error occurred while toggling todo status.\n */\nrouter.patch('/todos/:id/toggle', (req, res) => {\n    try {\n        const { id } = req.params;\n\n        // Input validation: Ensure ID is a valid positive integer\n        const todoId = parseInt(id, 10);\n        if (isNaN(todoId) || todoId <= 0) {\n            return res.status(400).json({ message: 'Invalid todo ID provided. ID must be a positive integer.' });\n        }\n\n        // Find the todo item by ID in the mock database\n        const todoIndex = todos.findIndex(todo => todo.id === todoId);\n\n        // If todo not found, return 404 Not Found\n        if (todoIndex === -1) {\n            return res.status(404).json({ message: `Todo with ID ${todoId} not found.` });\n        }\n\n        // Toggle the 'completed' status of the found todo item\n        todos[todoIndex].completed = !todos[todoIndex].completed;\n\n        // Return a 200 OK response with the updated todo item\n        res.status(200).json({\n            message: 'Todo status toggled successfully.',\n            todo: todos[todoIndex]\n        });\n\n    } catch (error) {\n        // Log the error for debugging purposes in a production environment\n        console.error(`Error toggling todo status for ID ${req.params.id}:`, error);\n        // Return a generic 500 Internal Server Error for unexpected issues\n        res.status(500).json({ message: 'An unexpected error occurred while toggling todo status.' });\n    }\n});\n\nmodule.exports = router;",
  "095077d3ab0ee21e8ef373ff837c2d650bb55eba9a414292fbda9013ac1b4a69": "const express = require('express');\nconst router = express.Router();\n\n/**\n * DELETE /api/todos/:id\n *\n * Deletes a todo item by its ID.\n *\n * @param {object} req - The Express request object.\n * @param {object} res - The Express response object.\n * @returns {void}\n */\nrouter.delete('/todos/:id', async (req, res) => {\n  try {\n    // 1. Input Validation: Validate the 'id' parameter from the URL.\n    // Ensure the ID is present and is a valid positive integer.\n    const todoId = parseInt(req.params.id, 10);\n\n    if (isNaN(todoId) || todoId <= 0) {\n      // Respond with a 400 Bad Request if the ID is invalid.\n      return res.status(400).json({ message: 'Invalid todo ID. ID must be a positive integer.' });\n    }\n\n    // 2. Business Logic: Attempt to delete the todo item from the database.\n    // In a real application, this would involve a database call, e.g.:\n    // const deletedTodo = await TodoModel.findByIdAndDelete(todoId);\n    //\n    // For demonstration, let's simulate a database operation.\n    // Assume `null` means not found, `true` means deleted successfully.\n    let isDeleted = null; // Default to not found\n\n    // --- Start Mock Database Interaction ---\n    // Replace this block with your actual database deletion logic.\n    // Example with a hypothetical `TodoService`:\n    // isDeleted = await TodoService.deleteTodo(todoId);\n    //\n    // For this example, we'll simulate a 404 for ID 999 and success for others.\n    if (todoId === 999) {\n      isDeleted = null; // Simulate todo not found\n    } else {\n      isDeleted = true; // Simulate successful deletion\n    }\n    // --- End Mock Database Interaction ---\n\n    // 3. Handle deletion result\n    if (isDeleted === null) {\n      // If `isDeleted` is null, it means the todo with the given ID was not found.\n      return res.status(404).json({ message: `Todo with ID ${todoId} not found.` });\n    } else if (isDeleted) {\n      // If `isDeleted` is true, the todo was successfully deleted.\n      // Send a 204 No Content response, which is standard for successful DELETE operations\n      // where no content is returned.\n      return res.status(204).send();\n    } else {\n      // This case handles scenarios where the deletion operation might fail\n      // for reasons other than 'not found' (e.g., database error, permissions).\n      // Your actual database service should return a more specific error or throw.\n      console.warn(`Deletion of todo ID ${todoId} returned an unexpected result.`);\n      return res.status(500).json({ message: 'Failed to delete todo due to an unexpected issue.' });\n    }\n\n  } catch (error) {\n    // 4. Error Handling: Catch any unexpected errors that occur during the process.\n    // Log the error for debugging purposes.\n    console.error(`Error deleting todo with ID ${req.params.id}:`, error);\n    // Respond with a 500 Internal Server Error.\n    return res.status(500).json({ message: 'An unexpected error occurred while deleting the todo.' });\n  }\n});\n\nmodule.exports = router;"
}