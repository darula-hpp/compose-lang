{
  "205791a29544ae44bc9351f92de1f363b860532f42d1fa5b5cb907e19909723b": "### FILE: generated/web/package.json\n{\n  \"name\": \"nextjs-todo-app\",\n  \"version\": \"0.1.0\",\n  \"private\": true,\n  \"scripts\": {\n    \"dev\": \"next dev\",\n    \"build\": \"next build\",\n    \"start\": \"next start\",\n    \"lint\": \"next lint\"\n  },\n  \"dependencies\": {\n    \"@tanstack/react-query\": \"^5.40.0\",\n    \"@tanstack/react-query-devtools\": \"^5.40.0\",\n    \"autoprefixer\": \"^10.4.19\",\n    \"clsx\": \"^2.1.1\",\n    \"date-fns\": \"^3.6.0\",\n    \"next\": \"14.2.3\",\n    \"next-themes\": \"^0.3.0\",\n    \"postcss\": \"^8.4.38\",\n    \"react\": \"^18.3.1\",\n    \"react-debounce-input\": \"^3.3.0\",\n    \"react-dom\": \"^18.3.1\",\n    \"react-hot-toast\": \"^2.4.1\",\n    \"tailwind-merge\": \"^2.3.0\",\n    \"tailwindcss\": \"^3.4.3\",\n    \"typescript\": \"^5.4.5\",\n    \"uuid\": \"^9.0.1\",\n    \"zod\": \"^3.23.8\"\n  },\n  \"devDependencies\": {\n    \"@types/node\": \"^20.12.12\",\n    \"@types/react\": \"^18.3.3\",\n    \"@types/react-dom\": \"^18.3.0\",\n    \"@types/react-debounce-input\": \"^3.2.3\",\n    \"@types/uuid\": \"^9.0.8\",\n    \"eslint\": \"^8.57.0\",\n    \"eslint-config-next\": \"14.2.3\"\n  }\n}\n\n### FILE: generated/web/tsconfig.json\n{\n  \"compilerOptions\": {\n    \"lib\": [\"dom\", \"dom.iterable\", \"esnext\"],\n    \"allowJs\": true,\n    \"skipLibCheck\": true,\n    \"strict\": true,\n    \"noEmit\": true,\n    \"esModuleInterop\": true,\n    \"module\": \"esnext\",\n    \"moduleResolution\": \"bundler\",\n    \"resolveJsonModule\": true,\n    \"isolatedModules\": true,\n    \"jsx\": \"preserve\",\n    \"incremental\": true,\n    \"plugins\": [\n      {\n        \"name\": \"next\"\n      }\n    ],\n    \"paths\": {\n      \"@/*\": [\"./*\"]\n    }\n  },\n  \"include\": [\"next-env.d.ts\", \"**/*.ts\", \"**/*.tsx\", \".next/types/**/*.ts\"],\n  \"exclude\": [\"node_modules\"]\n}\n\n### FILE: generated/web/next.config.js\n/** @type {import('next').NextConfig} */\nconst nextConfig = {\n  reactStrictMode: true,\n  swcMinify: true,\n};\n\nmodule.exports = nextConfig;\n\n### FILE: generated/web/tailwind.config.ts\nimport type { Config } from 'tailwindcss';\n\nconst config: Config = {\n  darkMode: 'class', // Enable dark mode based on 'class'\n  content: [\n    './pages/**/*.{js,ts,jsx,tsx,mdx}',\n    './components/**/*.{js,ts,jsx,tsx,mdx}',\n    './app/**/*.{js,ts,jsx,tsx,mdx}',\n  ],\n  theme: {\n    extend: {\n      colors: {\n        primary: {\n          50: '#eef2ff',\n          100: '#e0e7ff',\n          200: '#c7d2fe',\n          300: '#a5b4fc',\n          400: '#818cf8',\n          500: '#6366f1', // Main indigo\n          600: '#4f46e5',\n          700: '#4338ca',\n          800: '#3730a3',\n          900: '#312e81',\n          950: '#1e1b4b',\n        },\n        background: {\n          light: '#f8fafc', // Slate 50\n          dark: '#0f172a',  // Slate 900\n        },\n        card: {\n          light: '#ffffff',\n          dark: '#1e293b', // Slate 800\n        },\n        text: {\n          light: '#1e293b', // Slate 800\n          dark: '#f8fafc',  // Slate 50\n        },\n        secondary: {\n          light: '#64748b', // Slate 500\n          dark: '#94a3b8',  // Slate 400\n        },\n      },\n      boxShadow: {\n        'subtle': '0 4px 6px -1px rgba(0, 0, 0, 0.05), 0 2px 4px -1px rgba(0, 0, 0, 0.03)',\n        'card-hover': '0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05)',\n      },\n    },\n  },\n  plugins: [],\n};\nexport default config;\n\n### FILE: generated/web/postcss.config.js\nmodule.exports = {\n  plugins: {\n    tailwindcss: {},\n    autoprefixer: {},\n  },\n};\n\n### FILE: generated/web/public/favicon.ico\n(empty - placeholder for a real favicon)\n\n### FILE: generated/web/app/globals.css\n@tailwind base;\n@tailwind components;\n@tailwind utilities;\n\n@layer base {\n  body {\n    @apply bg-background-light text-text-light dark:bg-background-dark dark:text-text-dark transition-colors duration-300;\n  }\n\n  /* Focus indicators for accessibility */\n  *:focus-visible {\n    @apply outline-none ring-2 ring-primary-500 ring-offset-2 dark:ring-offset-background-dark;\n  }\n}\n\n### FILE: generated/web/app/layout.tsx\nimport type { Metadata } from 'next';\nimport { Inter } from 'next/font/google';\nimport './globals.css';\nimport { ThemeProvider } from 'next-themes';\nimport { QueryClientProvider } from '@tanstack/react-query';\nimport { ReactQueryDevtools } from '@tanstack/react-query-devtools';\nimport { Toaster } from 'react-hot-toast';\nimport { queryClient } from '@/lib/queryClient';\n\nconst inter = Inter({ subsets: ['latin'] });\n\nexport const metadata: Metadata = {\n  title: 'Next.js Todo App',\n  description: 'A production-ready Next.js Todo application with persistence, filtering, and dark mode.',\n};\n\nexport default function RootLayout({\n  children,\n}: Readonly<{\n  children: React.ReactNode;\n}>) {\n  return (\n    <html lang=\"en\" suppressHydrationWarning>\n      <body className={inter.className}>\n        <ThemeProvider attribute=\"class\" defaultTheme=\"system\" enableSystem>\n          <QueryClientProvider client={queryClient}>\n            {children}\n            <Toaster position=\"top-right\" />\n            <ReactQueryDevtools initialIsOpen={false} />\n          </QueryClientProvider>\n        </ThemeProvider>\n      </body>\n    </html>\n  );\n}\n\n### FILE: generated/web/app/page.tsx\n'use client';\n\nimport { useState, useEffect } from 'react';\nimport TodoForm from '@/components/TodoForm';\nimport TodoList from '@/components/TodoList';\nimport FilterButtons from '@/components/FilterButtons';\nimport Pagination from '@/components/Pagination';\nimport ThemeToggle from '@/components/ThemeToggle';\nimport { useTodos } from '@/hooks/useTodos';\nimport { TodoFilter } from '@/lib/types';\nimport LoadingSpinner from '@/components/LoadingSpinner';\nimport ErrorDisplay from '@/components/ErrorDisplay';\nimport { DebounceInput } from 'react-debounce-input';\nimport { useLocalStorage } from '@/hooks/useLocalStorage';\nimport { Todo } from '@/lib/types';\n\nconst ITEMS_PER_PAGE = 50;\n\nexport default function Home() {\n  const [filter, setFilter] = useState<TodoFilter>('all');\n  const [page, setPage] = useState(1);\n  const [searchQuery, setSearchQuery] = useState('');\n\n  // Use localStorage for caching completed todos for offline access\n  // This is a simplified approach. A full offline solution would involve service workers.\n  const [cachedCompletedTodos, setCachedCompletedTodos] = useLocalStorage<Todo[]>('completedTodosCache', []);\n\n  const { data, isLoading, isError, error, isFetching } = useTodos({\n    filter,\n    page,\n    limit: ITEMS_PER_PAGE,\n    search: searchQuery,\n  });\n\n  const todos = data?.todos || [];\n  const totalPages = data?.totalPages || 0;\n\n  // Update localStorage cache when todos are fetched and completed\n  useEffect(() => {\n    if (todos.length > 0) {\n      const completed = todos.filter(todo => todo.completed && !todo.deletedAt);\n      setCachedCompletedTodos(completed);\n    }\n  }, [todos, setCachedCompletedTodos]);\n\n  // If offline, we could potentially display cachedCompletedTodos here\n  // For this demo, we'll just keep the cache updated.\n\n  const handleFilterChange = (newFilter: TodoFilter) => {\n    setFilter(newFilter);\n    setPage(1); // Reset page on filter change\n  };\n\n  const handleSearchChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    setSearchQuery(e.target.value);\n    setPage(1); // Reset page on search change\n  };\n\n  return (\n    <div className=\"min-h-screen flex flex-col items-center py-8 px-4 sm:px-6 lg:px-8\">\n      <header className=\"w-full max-w-3xl flex justify-between items-center mb-8\">\n        <h1 className=\"text-4xl font-extrabold text-primary-700 dark:text-primary-400\">Todo App</h1>\n        <ThemeToggle />\n      </header>\n\n      <main className=\"w-full max-w-3xl bg-card-light dark:bg-card-dark rounded-lg shadow-subtle p-6 space-y-6\">\n        <TodoForm />\n\n        <div className=\"flex flex-col sm:flex-row justify-between items-center gap-4\">\n          <FilterButtons currentFilter={filter} onFilterChange={handleFilterChange} />\n          <DebounceInput\n            minLength={2}\n            debounceTimeout={300}\n            onChange={handleSearchChange}\n            value={searchQuery}\n            placeholder=\"Search todos...\"\n            aria-label=\"Search todos\"\n            className=\"w-full sm:w-auto px-4 py-2 border border-gray-300 dark:border-gray-700 rounded-md focus:outline-none focus:ring-2 focus:ring-primary-500 bg-white dark:bg-gray-700 text-text-light dark:text-text-dark transition-colors duration-200\"\n          />\n        </div>\n\n        {isError && <ErrorDisplay message={error?.message || 'Failed to load todos.'} />}\n\n        {(isLoading || isFetching) && <LoadingSpinner />}\n\n        {!isLoading && !isFetching && todos.length === 0 && (\n          <p className=\"text-center text-secondary-light dark:text-secondary-dark mt-8\">\n            No todos found for the current filter and search.\n          </p>\n        )}\n\n        {!isLoading && !isError && todos.length > 0 && (\n          <>\n            <TodoList todos={todos} />\n            <Pagination currentPage={page} totalPages={totalPages} onPageChange={setPage} />\n          </>\n        )}\n      </main>\n    </div>\n  );\n}\n\n### FILE: generated/web/components/TodoCard.tsx\nimport React, { useState } from 'react';\nimport { format, isToday, isTomorrow, isPast } from 'date-fns';\nimport { Todo } from '@/lib/types';\nimport { useTodos } from '@/hooks/useTodos';\nimport clsx from 'clsx';\nimport { toast } from 'react-hot-toast';\nimport LoadingSpinner from './LoadingSpinner';\nimport Modal from './Modal';\n\ninterface TodoCardProps {\n  todo: Todo;\n}\n\nconst TodoCard: React.FC<TodoCardProps> = ({ todo }) => {\n  const { updateTodoMutation, deleteTodoMutation, getTodoDetailsQuery } = useTodos();\n  const [isExpanded, setIsExpanded] = useState(false);\n  const [showDeleteModal, setShowDeleteModal] = useState(false);\n\n  // Lazy load details only when expanded\n  const { data: detailedTodo, isLoading: isLoadingDetails } = getTodoDetailsQuery(todo.id, isExpanded);\n\n  const displayTodo = detailedTodo || todo; // Use detailedTodo if loaded, otherwise initial todo\n\n  const handleToggleComplete = async () => {\n    try {\n      await updateTodoMutation.mutateAsync({\n        id: todo.id,\n        completed: !todo.completed,\n      });\n      toast.success(`Todo \"${todo.title}\" marked ${todo.completed ? 'incomplete' : 'complete'}!`);\n    } catch (error) {\n      toast.error('Failed to update todo status.');\n    }\n  };\n\n  const handleDelete = async () => {\n    try {\n      await deleteTodoMutation.mutateAsync(todo.id);\n      toast.success(`Todo \"${todo.title}\" deleted!`);\n      setShowDeleteModal(false);\n    } catch (error) {\n      toast.error('Failed to delete todo.');\n    }\n  };\n\n  const getDueDateLabel = (dueDate: Date | undefined) => {\n    if (!dueDate) return null;\n    if (isToday(dueDate)) return 'Today';\n    if (isTomorrow(dueDate)) return 'Tomorrow';\n    if (isPast(dueDate, new Date())) return 'Overdue';\n    return format(dueDate, 'MMM d, yyyy');\n  };\n\n  const dueDateLabel = getDueDateLabel(displayTodo.dueDate);\n\n  return (\n    <div\n      className={clsx(\n        'bg-card-light dark:bg-card-dark rounded-lg shadow-subtle p-4 mb-4 border border-gray-200 dark:border-gray-700',\n        'hover:shadow-card-hover transition-all duration-200 ease-in-out',\n        'flex flex-col',\n        todo.completed && 'opacity-70 border-primary-300 dark:border-primary-700',\n        todo.deletedAt && 'hidden' // Soft deleted items are hidden from the UI\n      )}\n      role=\"listitem\"\n      aria-labelledby={`todo-title-${todo.id}`}\n      aria-describedby={`todo-description-${todo.id}`}\n    >\n      <div className=\"flex items-center justify-between gap-4\">\n        <div className=\"flex items-center flex-grow min-w-0\">\n          <input\n            type=\"checkbox\"\n            checked={todo.completed}\n            onChange={handleToggleComplete}\n            className=\"form-checkbox h-5 w-5 text-primary-600 rounded focus:ring-primary-500 cursor-pointer\"\n            aria-label={`Mark \"${todo.title}\" as ${todo.completed ? 'incomplete' : 'complete'}`}\n            disabled={updateTodoMutation.isPending}\n          />\n          <h3\n            id={`todo-title-${todo.id}`}\n            className={clsx(\n              'ml-3 text-lg font-semibold break-words',\n              todo.completed && 'line-through text-secondary-light dark:text-secondary-dark'\n            )}\n          >\n            {todo.title}\n          </h3>\n        </div>\n\n        <div className=\"flex items-center gap-2 flex-shrink-0\">\n          {dueDateLabel && (\n            <span\n              className={clsx(\n                'px-2 py-1 text-xs font-medium rounded-full',\n                isPast(displayTodo.dueDate!, new Date()) && !todo.completed\n                  ? 'bg-red-100 text-red-800 dark:bg-red-900 dark:text-red-200'\n                  : 'bg-primary-100 text-primary-800 dark:bg-primary-900 dark:text-primary-200'\n              )}\n              aria-label={`Due date: ${dueDateLabel}`}\n            >\n              {dueDateLabel}\n            </span>\n          )}\n\n          <button\n            onClick={() => setIsExpanded(!isExpanded)}\n            className=\"p-1 rounded-full text-secondary-light dark:text-secondary-dark hover:bg-gray-200 dark:hover:bg-gray-700 focus:outline-none focus-visible:ring-2 focus-visible:ring-primary-500\"\n            aria-expanded={isExpanded}\n            aria-controls={`todo-details-${todo.id}`}\n            aria-label={isExpanded ? 'Collapse todo details' : 'Expand todo details'}\n          >\n            <svg\n              className={clsx('w-5 h-5 transition-transform duration-200', isExpanded ? 'rotate-180' : 'rotate-0')}\n              fill=\"none\"\n              stroke=\"currentColor\"\n              viewBox=\"0 0 24 24\"\n              xmlns=\"http://www.w3.org/2000/svg\"\n            >\n              <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth=\"2\" d=\"M19 9l-7 7-7-7\"></path>\n            </svg>\n          </button>\n\n          <button\n            onClick={() => setShowDeleteModal(true)}\n            className=\"p-1 rounded-full text-red-600 hover:bg-red-100 dark:hover:bg-red-900 focus:outline-none focus-visible:ring-2 focus-visible:ring-red-500\"\n            aria-label={`Delete todo \"${todo.title}\"`}\n            disabled={deleteTodoMutation.isPending}\n          >\n            {deleteTodoMutation.isPending ? (\n              <LoadingSpinner size=\"sm\" />\n            ) : (\n              <svg\n                className=\"w-5 h-5\"\n                fill=\"none\"\n                stroke=\"currentColor\"\n                viewBox=\"0 0 24 24\"\n                xmlns=\"http://www.w3.org/2000/svg\"\n              >\n                <path\n                  strokeLinecap=\"round\"\n                  strokeLinejoin=\"round\"\n                  strokeWidth=\"2\"\n                  d=\"M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16\"\n                ></path>\n              </svg>\n            )}\n          </button>\n        </div>\n      </div>\n\n      {isExpanded && (\n        <div id={`todo-details-${todo.id}`} className=\"mt-4 pt-4 border-t border-gray-200 dark:border-gray-700 text-sm text-secondary-light dark:text-secondary-dark\">\n          {isLoadingDetails ? (\n            <div className=\"flex justify-center py-2\"><LoadingSpinner size=\"sm\" /></div>\n          ) : (\n            <>\n              {displayTodo.description && (\n                <p className=\"mb-2\" id={`todo-description-${todo.id}`}>\n                  <span className=\"font-medium text-text-light dark:text-text-dark\">Description:</span> {displayTodo.description}\n                </p>\n              )}\n              <p>\n                <span className=\"font-medium text-text-light dark:text-text-dark\">Created:</span> {format(displayTodo.createdAt, 'MMM d, yyyy HH:mm')}\n              </p>\n              <p>\n                <span className=\"font-medium text-text-light dark:text-text-dark\">Last Updated:</span> {format(displayTodo.updatedAt, 'MMM d, yyyy HH:mm')}\n              </p>\n            </>\n          )}\n        </div>\n      )}\n\n      <Modal\n        isOpen={showDeleteModal}\n        onClose={() => setShowDeleteModal(false)}\n        title=\"Confirm Delete\"\n        description={`Are you sure you want to delete \"${todo.title}\"? This action cannot be undone.`}\n      >\n        <div className=\"flex justify-end gap-2 mt-4\">\n          <button\n            onClick={() => setShowDeleteModal(false)}\n            className=\"px-4 py-2 rounded-md bg-gray-200 dark:bg-gray-700 text-text-light dark:text-text-dark hover:bg-gray-300 dark:hover:bg-gray-600 transition-colors duration-200 focus:outline-none focus-visible:ring-2 focus-visible:ring-primary-500\"\n            aria-label=\"Cancel deletion\"\n          >\n            Cancel\n          </button>\n          <button\n            onClick={handleDelete}\n            className=\"px-4 py-2 rounded-md bg-red-600 text-white hover:bg-red-700 transition-colors duration-200 focus:outline-none focus-visible:ring-2 focus-visible:ring-red-500\"\n            aria-label={`Confirm deletion of todo \"${todo.title}\"`}\n            disabled={deleteTodoMutation.isPending}\n          >\n            {deleteTodoMutation.isPending ? <LoadingSpinner size=\"sm\" color=\"white\" /> : 'Delete'}\n          </button>\n        </div>\n      </Modal>\n    </div>\n  );\n};\n\nexport default TodoCard;\n\n### FILE: generated/web/components/TodoForm.tsx\nimport React, { useState } from 'react';\nimport { useTodos } from '@/hooks/useTodos';\nimport { toast } from 'react-hot-toast';\nimport { TodoSchema } from '@/lib/validation';\nimport { format } from 'date-fns';\nimport LoadingSpinner from './LoadingSpinner';\n\nconst TodoForm: React.FC = () => {\n  const [title, setTitle] = useState('');\n  const [dueDate, setDueDate] = useState<string>('');\n  const [description, setDescription] = useState('');\n  const { createTodoMutation } = useTodos();\n\n  const handleSubmit = async (e: React.FormEvent) => {\n    e.preventDefault();\n\n    // Frontend validation\n    const validationResult = TodoSchema.safeParse({\n      title: title.trim(),\n      dueDate: dueDate ? new Date(dueDate) : undefined,\n      description: description.trim() || undefined,\n    });\n\n    if (!validationResult.success) {\n      validationResult.error.errors.forEach((err) => toast.error(err.message));\n      return;\n    }\n\n    try {\n      await createTodoMutation.mutateAsync({\n        title: validationResult.data.title,\n        dueDate: validationResult.data.dueDate,\n        description: validationResult.data.description,\n      });\n      toast.success('Todo created successfully!');\n      setTitle('');\n      setDueDate('');\n      setDescription('');\n    } catch (error: any) {\n      toast.error(error.message || 'Failed to create todo.');\n    }\n  };\n\n  // Get today's date in YYYY-MM-DD format for min attribute\n  const today = format(new Date(), 'yyyy-MM-dd');\n\n  return (\n    <form onSubmit={handleSubmit} className=\"p-4 bg-gray-50 dark:bg-gray-800 rounded-lg shadow-inner\">\n      <div className=\"mb-4\">\n        <label htmlFor=\"title\" className=\"block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1\">\n          Title <span className=\"text-red-500\">*</span>\n        </label>\n        <input\n          type=\"text\"\n          id=\"title\"\n          value={title}\n          onChange={(e) => setTitle(e.target.value)}\n          placeholder=\"What needs to be done?\"\n          className=\"w-full px-4 py-2 border border-gray-300 dark:border-gray-700 rounded-md focus:outline-none focus:ring-2 focus:ring-primary-500 bg-white dark:bg-gray-700 text-text-light dark:text-text-dark transition-colors duration-200\"\n          required\n          maxLength={200}\n          aria-required=\"true\"\n          aria-label=\"Todo title\"\n        />\n      </div>\n\n      <div className=\"mb-4\">\n        <label htmlFor=\"description\" className=\"block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1\">\n          Description (optional)\n        </label>\n        <textarea\n          id=\"description\"\n          value={description}\n          onChange={(e) => setDescription(e.target.value)}\n          placeholder=\"Add more details about this todo...\"\n          rows={3}\n          className=\"w-full px-4 py-2 border border-gray-300 dark:border-gray-700 rounded-md focus:outline-none focus:ring-2 focus:ring-primary-500 bg-white dark:bg-gray-700 text-text-light dark:text-text-dark transition-colors duration-200 resize-y\"\n          maxLength={500}\n          aria-label=\"Todo description\"\n        />\n      </div>\n\n      <div className=\"mb-6\">\n        <label htmlFor=\"dueDate\" className=\"block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1\">\n          Due Date (optional)\n        </label>\n        <input\n          type=\"date\"\n          id=\"dueDate\"\n          value={dueDate}\n          onChange={(e) => setDueDate(e.target.value)}\n          min={today}\n          className=\"w-full px-4 py-2 border border-gray-300 dark:border-gray-700 rounded-md focus:outline-none focus:ring-2 focus:ring-primary-500 bg-white dark:bg-gray-700 text-text-light dark:text-text-dark transition-colors duration-200\"\n          aria-label=\"Todo due date\"\n        />\n      </div>\n\n      <button\n        type=\"submit\"\n        className=\"w-full bg-primary-600 text-white py-2 px-4 rounded-md hover:bg-primary-700 transition-colors duration-200 focus:outline-none focus-visible:ring-2 focus-visible:ring-primary-500 focus-visible:ring-offset-2 dark:focus-visible:ring-offset-background-dark flex items-center justify-center\"\n        disabled={createTodoMutation.isPending}\n        aria-label=\"Add new todo\"\n      >\n        {createTodoMutation.isPending ? <LoadingSpinner size=\"sm\" color=\"white\" /> : 'Add Todo'}\n      </button>\n    </form>\n  );\n};\n\nexport default TodoForm;\n\n### FILE: generated/web/components/TodoList.tsx\nimport React from 'react';\nimport { Todo } from '@/lib/types';\nimport TodoCard from './TodoCard';\n\ninterface TodoListProps {\n  todos: Todo[];\n}\n\nconst TodoList: React.FC<TodoListProps> = ({ todos }) => {\n  return (\n    <div className=\"space-y-4\" role=\"list\" aria-label=\"List of todos\">\n      {todos.map((todo) => (\n        <TodoCard key={todo.id} todo={todo} />\n      ))}\n    </div>\n  );\n};\n\nexport default TodoList;\n\n### FILE: generated/web/components/FilterButtons.tsx\nimport React from 'react';\nimport { TodoFilter } from '@/lib/types';\nimport clsx from 'clsx';\n\ninterface FilterButtonsProps {\n  currentFilter: TodoFilter;\n  onFilterChange: (filter: TodoFilter) => void;\n}\n\nconst FilterButtons: React.FC<FilterButtonsProps> = ({ currentFilter, onFilterChange }) => {\n  const filters: { label: string; value: TodoFilter }[] = [\n    { label: 'All', value: 'all' },\n    { label: 'Active', value: 'active' },\n    { label: 'Completed', value: 'completed' },\n  ];\n\n  return (\n    <div className=\"flex space-x-2 bg-gray-100 dark:bg-gray-800 p-1 rounded-md\" role=\"group\" aria-label=\"Todo filters\">\n      {filters.map((filter) => (\n        <button\n          key={filter.value}\n          onClick={() => onFilterChange(filter.value)}\n          className={clsx(\n            'px-4 py-2 rounded-md text-sm font-medium transition-colors duration-200',\n            currentFilter === filter.value\n              ? 'bg-primary-600 text-white shadow-sm'\n              : 'text-secondary-light dark:text-secondary-dark hover:bg-gray-200 dark:hover:bg-gray-700',\n            'focus:outline-none focus-visible:ring-2 focus-visible:ring-primary-500'\n          )}\n          aria-pressed={currentFilter === filter.value}\n          aria-label={`Show ${filter.label} todos`}\n        >\n          {filter.label}\n        </button>\n      ))}\n    </div>\n  );\n};\n\nexport default FilterButtons;\n\n### FILE: generated/web/components/Pagination.tsx\nimport React from 'react';\nimport clsx from 'clsx';\n\ninterface PaginationProps {\n  currentPage: number;\n  totalPages: number;\n  onPageChange: (page: number) => void;\n}\n\nconst Pagination: React.FC<PaginationProps> = ({ currentPage, totalPages, onPageChange }) => {\n  if (totalPages <= 1) return null;\n\n  const pages = Array.from({ length: totalPages }, (_, i) => i + 1);\n\n  return (\n    <nav className=\"flex justify-center items-center space-x-2 mt-6\" aria-label=\"Pagination\">\n      <button\n        onClick={() => onPageChange(currentPage - 1)}\n        disabled={currentPage === 1}\n        className=\"p-2 rounded-md bg-gray-100 dark:bg-gray-700 text-secondary-light dark:text-secondary-dark hover:bg-gray-200 dark:hover:bg-gray-600 disabled:opacity-50 disabled:cursor-not-allowed transition-colors duration-200 focus:outline-none focus-visible:ring-2 focus-visible:ring-primary-500\"\n        aria-label=\"Previous page\"\n      >\n        <svg className=\"w-5 h-5\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\" xmlns=\"http://www.w3.org/2000/svg\">\n          <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth=\"2\" d=\"M15 19l-7-7 7-7\"></path>\n        </svg>\n      </button>\n\n      {pages.map((page) => (\n        <button\n          key={page}\n          onClick={() => onPageChange(page)}\n          className={clsx(\n            'px-4 py-2 rounded-md text-sm font-medium transition-colors duration-200',\n            currentPage === page\n              ? 'bg-primary-600 text-white shadow-sm'\n              : 'bg-gray-100 dark:bg-gray-700 text-secondary-light dark:text-secondary-dark hover:bg-gray-200 dark:hover:bg-gray-600',\n            'focus:outline-none focus-visible:ring-2 focus-visible:ring-primary-500'\n          )}\n          aria-current={currentPage === page ? 'page' : undefined}\n          aria-label={`Go to page ${page}`}\n        >\n          {page}\n        </button>\n      ))}\n\n      <button\n        onClick={() => onPageChange(currentPage + 1)}\n        disabled={currentPage === totalPages}\n        className=\"p-2 rounded-md bg-gray-100 dark:bg-gray-700 text-secondary-light dark:text-secondary-dark hover:bg-gray-200 dark:hover:bg-gray-600 disabled:opacity-50 disabled:cursor-not-allowed transition-colors duration-200 focus:outline-none focus-visible:ring-2 focus-visible:ring-primary-500\"\n        aria-label=\"Next page\"\n      >\n        <svg className=\"w-5 h-5\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\" xmlns=\"http://www.w3.org/2000/svg\">\n          <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth=\"2\" d=\"M9 5l7 7-7 7\"></path>\n        </svg>\n      </button>\n    </nav>\n  );\n};\n\nexport default Pagination;\n\n### FILE: generated/web/components/ThemeToggle.tsx\n'use client';\n\nimport { useTheme } from 'next-themes';\nimport { useState, useEffect } from 'react';\nimport clsx from 'clsx';\n\nconst ThemeToggle: React.FC = () => {\n  const [mounted, setMounted] = useState(false);\n  const { theme, setTheme } = useTheme();\n\n  // useEffect only runs on the client, so now we can safely show the UI\n  useEffect(() => {\n    setMounted(true);\n  }, []);\n\n  if (!mounted) {\n    return (\n      <div className=\"w-10 h-10 rounded-full bg-gray-200 dark:bg-gray-700 animate-pulse\" aria-hidden=\"true\"></div>\n    ); // Placeholder for hydration mismatch\n  }\n\n  const isDark = theme === 'dark';\n\n  return (\n    <button\n      onClick={() => setTheme(isDark ? 'light' : 'dark')}\n      className={clsx(\n        'relative w-10 h-10 rounded-full flex items-center justify-center',\n        'bg-gray-200 dark:bg-gray-700 text-gray-700 dark:text-gray-200',\n        'hover:bg-gray-300 dark:hover:bg-gray-600 transition-colors duration-200',\n        'focus:outline-none focus-visible:ring-2 focus-visible:ring-primary-500'\n      )}\n      aria-label={isDark ? 'Switch to light mode' : 'Switch to dark mode'}\n    >\n      {isDark ? (\n        <svg\n          className=\"w-6 h-6\"\n          fill=\"none\"\n          stroke=\"currentColor\"\n          viewBox=\"0 0 24 24\"\n          xmlns=\"http://www.w3.org/2000/svg\"\n        >\n          <path\n            strokeLinecap=\"round\"\n            strokeLinejoin=\"round\"\n            strokeWidth=\"2\"\n            d=\"M12 3v1m0 16v1m9-9h1M3 12H2m15.325-4.275l.707-.707M6.707 17.293l-.707.707M16.95 18.364l.707.707M6.343 6.343l-.707-.707M12 16a4 4 0 100-8 4 4 0 000 8z\"\n          ></path>\n        </svg>\n      ) : (\n        <svg\n          className=\"w-6 h-6\"\n          fill=\"none\"\n          stroke=\"currentColor\"\n          viewBox=\"0 0 24 24\"\n          xmlns=\"http://www.w3.org/2000/svg\"\n        >\n          <path\n            strokeLinecap=\"round\"\n            strokeLinejoin=\"round\"\n            strokeWidth=\"2\"\n            d=\"M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z\"\n          ></path>\n        </svg>\n      )}\n    </button>\n  );\n};\n\nexport default ThemeToggle;\n\n### FILE: generated/web/components/LoadingSpinner.tsx\nimport React from 'react';\nimport clsx from 'clsx';\n\ninterface LoadingSpinnerProps {\n  size?: 'sm' | 'md' | 'lg';\n  color?: string; // Tailwind color class, e.g., 'text-primary-500'\n}\n\nconst LoadingSpinner: React.FC<LoadingSpinnerProps> = ({ size = 'md', color = 'text-primary-500' }) => {\n  const spinnerSize = clsx({\n    'w-4 h-4': size === 'sm',\n    'w-6 h-6': size === 'md',\n    'w-8 h-8': size === 'lg',\n  });\n\n  const spinnerBorder = clsx({\n    'border-2': size === 'sm',\n    'border-3': size === 'md',\n    'border-4': size === 'lg',\n  });\n\n  return (\n    <div\n      className={clsx(\n        'inline-block animate-spin rounded-full border-solid border-current border-r-transparent align-[-0.125em] motion-reduce:animate-[spin_1.5s_linear_infinite]',\n        spinnerSize,\n        spinnerBorder,\n        color\n      )}\n      role=\"status\"\n      aria-label=\"Loading\"\n    >\n      <span className=\"!absolute !-m-px !h-px !w-px !overflow-hidden !whitespace-nowrap !border-0 !p-0 ![clip:rect(0,0,0,0)]\">\n        Loading...\n      </span>\n    </div>\n  );\n};\n\nexport default LoadingSpinner;\n\n### FILE: generated/web/components/ErrorDisplay.tsx\nimport React from 'react';\n\ninterface ErrorDisplayProps {\n  message: string;\n}\n\nconst ErrorDisplay: React.FC<ErrorDisplayProps> = ({ message }) => {\n  return (\n    <div\n      className=\"bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded relative\"\n      role=\"alert\"\n    >\n      <strong className=\"font-bold\">Error!</strong>\n      <span className=\"block sm:inline ml-2\">{message}</span>\n    </div>\n  );\n};\n\nexport default ErrorDisplay;\n\n### FILE: generated/web/components/Modal.tsx\nimport React, { useEffect, useRef } from 'react';\nimport { createPortal } from 'react-dom';\nimport clsx from 'clsx';\n\ninterface ModalProps {\n  isOpen: boolean;\n  onClose: () => void;\n  title: string;\n  description?: string;\n  children: React.ReactNode;\n}\n\nconst Modal: React.FC<ModalProps> = ({ isOpen, onClose, title, description, children }) => {\n  const modalRef = useRef<HTMLDivElement>(null);\n\n  useEffect(() => {\n    if (!isOpen) return;\n\n    const handleEscape = (event: KeyboardEvent) => {\n      if (event.key === 'Escape') {\n        onClose();\n      }\n    };\n\n    document.addEventListener('keydown', handleEscape);\n\n    // Focus the first focusable element in the modal when it opens\n    const focusableElements = modalRef.current?.querySelectorAll(\n      'button, [href], input, select, textarea, [tabindex]:not([tabindex=\"-1\"])'\n    );\n    if (focusableElements && focusableElements.length > 0) {\n      (focusableElements[0] as HTMLElement).focus();\n    }\n\n    return () => {\n      document.removeEventListener('keydown', handleEscape);\n    };\n  }, [isOpen, onClose]);\n\n  if (!isOpen) return null;\n\n  return createPortal(\n    <div\n      className=\"fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-50 p-4\"\n      role=\"dialog\"\n      aria-modal=\"true\"\n      aria-labelledby=\"modal-title\"\n      aria-describedby=\"modal-description\"\n    >\n      <div\n        ref={modalRef}\n        className={clsx(\n          'bg-card-light dark:bg-card-dark rounded-lg shadow-lg p-6 w-full max-w-md',\n          'transform transition-all duration-300 ease-out',\n          isOpen ? 'scale-100 opacity-100' : 'scale-95 opacity-0'\n        )}\n        tabIndex={-1} // Make the modal content focusable\n      >\n        <div className=\"flex justify-between items-center mb-4\">\n          <h2 id=\"modal-title\" className=\"text-xl font-bold text-text-light dark:text-text-dark\">\n            {title}\n          </h2>\n          <button\n            onClick={onClose}\n            className=\"p-1 rounded-full text-secondary-light dark:text-secondary-dark hover:bg-gray-200 dark:hover:bg-gray-700 focus:outline-none focus-visible:ring-2 focus-visible:ring-primary-500\"\n            aria-label=\"Close modal\"\n          >\n            <svg\n              className=\"w-6 h-6\"\n              fill=\"none\"\n              stroke=\"currentColor\"\n              viewBox=\"0 0 24 24\"\n              xmlns=\"http://www.w3.org/2000/svg\"\n            >\n              <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth=\"2\" d=\"M6 18L18 6M6 6l12 12\"></path>\n            </svg>\n          </button>\n        </div>\n        {description && (\n          <p id=\"modal-description\" className=\"text-secondary-light dark:text-secondary-dark mb-4\">\n            {description}\n          </p>\n        )}\n        {children}\n      </div>\n    </div>,\n    document.body\n  );\n};\n\nexport default Modal;\n\n### FILE: generated/web/hooks/useTodos.ts\nimport { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';\nimport { Todo, CreateTodoPayload, UpdateTodoPayload, TodoFilter, PaginatedTodos } from '@/lib/types';\nimport { api } from '@/lib/api';\nimport { toast } from 'react-hot-toast';\n\ninterface UseTodosOptions {\n  filter?: TodoFilter;\n  page?: number;\n  limit?: number;\n  search?: string;\n}\n\nexport const useTodos = ({ filter = 'all', page = 1, limit = 50, search = '' }: UseTodosOptions = {}) => {\n  const queryClient = useQueryClient();\n\n  // Query for fetching todos\n  const todosQuery = useQuery<PaginatedTodos, Error>({\n    queryKey: ['todos', { filter, page, limit, search }],\n    queryFn: async () => {\n      const params = new URLSearchParams();\n      if (filter !== 'all') params.append('status', filter);\n      params.append('page', String(page));\n      params.append('limit', String(limit));\n      if (search) params.append('search', search);\n      return api.get<PaginatedTodos>(`/api/todos?${params.toString()}`);\n    },\n    staleTime: 1000 * 60 * 5, // 5 minutes\n    keepPreviousData: true, // Keep old data while fetching new page/filter\n  });\n\n  // Query for fetching a single todo's details (lazy load)\n  const getTodoDetailsQuery = (id: string, enabled: boolean) => useQuery<Todo, Error>({\n    queryKey: ['todo', id],\n    queryFn: () => api.get<Todo>(`/api/todos/${id}`),\n    enabled: enabled, // Only fetch when enabled (e.g., card is expanded)\n    staleTime: 1000 * 60 * 10, // 10 minutes\n  });\n\n  // Mutation for creating a todo\n  const createTodoMutation = useMutation<Todo, Error, CreateTodoPayload>({\n    mutationFn: (newTodo) => api.post<Todo>('/api/todos', newTodo),\n    onSuccess: () => {\n      queryClient.invalidateQueries({ queryKey: ['todos'] }); // Invalidate all todo lists\n    },\n    onError: (error) => {\n      toast.error(`Error creating todo: ${error.message}`);\n    },\n  });\n\n  // Mutation for updating a todo\n  const updateTodoMutation = useMutation<Todo, Error, UpdateTodoPayload>({\n    mutationFn: ({ id, ...updates }) => api.put<Todo>(`/api/todos/${id}`, updates),\n    onMutate: async (updatedTodo) => {\n      // Cancel any outgoing refetches for the todos list\n      await queryClient.cancelQueries({ queryKey: ['todos'] });\n      await queryClient.cancelQueries({ queryKey: ['todo', updatedTodo.id] });\n\n      // Snapshot the previous value\n      const previousTodos = queryClient.getQueryData<PaginatedTodos>(['todos', { filter, page, limit, search }]);\n      const previousTodoDetail = queryClient.getQueryData<Todo>(['todo', updatedTodo.id]);\n\n      // Optimistically update the todos list\n      queryClient.setQueryData<PaginatedTodos>(['todos', { filter, page, limit, search }], (old) => {\n        if (!old) return old;\n        return {\n          ...old,\n          todos: old.todos.map((todo) =>\n            todo.id === updatedTodo.id ? { ...todo, ...updatedTodo } : todo\n          ),\n        };\n      });\n\n      // Optimistically update the single todo detail\n      queryClient.setQueryData<Todo>(['todo', updatedTodo.id], (old) => {\n        if (!old) return old;\n        return { ...old, ...updatedTodo };\n      });\n\n      return { previousTodos, previousTodoDetail };\n    },\n    onError: (error, updatedTodo, context) => {\n      toast.error(`Error updating todo: ${error.message}`);\n      // Rollback to the previous value on error\n      if (context?.previousTodos) {\n        queryClient.setQueryData(['todos', { filter, page, limit, search }], context.previousTodos);\n      }\n      if (context?.previousTodoDetail) {\n        queryClient.setQueryData(['todo', updatedTodo.id], context.previousTodoDetail);\n      }\n    },\n    onSettled: (data, error, variables) => {\n      // Invalidate queries to refetch and ensure consistency\n      queryClient.invalidateQueries({ queryKey: ['todos'] });\n      queryClient.invalidateQueries({ queryKey: ['todo', variables.id] });\n    },\n  });\n\n  // Mutation for deleting a todo (soft delete)\n  const deleteTodoMutation = useMutation<void, Error, string>({\n    mutationFn: (id) => api.delete(`/api/todos/${id}`),\n    onMutate: async (id) => {\n      await queryClient.cancelQueries({ queryKey: ['todos'] });\n      await queryClient.cancelQueries({ queryKey: ['todo', id] });\n\n      const previousTodos = queryClient.getQueryData<PaginatedTodos>(['todos', { filter, page, limit, search }]);\n      const previousTodoDetail = queryClient.getQueryData<Todo>(['todo', id]);\n\n      queryClient.setQueryData<PaginatedTodos>(['todos', { filter, page, limit, search }], (old) => {\n        if (!old) return old;\n        return {\n          ...old,\n          todos: old.todos.map((todo) =>\n            todo.id === id ? { ...todo, deletedAt: new Date().toISOString() } : todo\n          ),\n        };\n      });\n\n      queryClient.setQueryData<Todo>(['todo', id], (old) => {\n        if (!old) return old;\n        return { ...old, deletedAt: new Date().toISOString() };\n      });\n\n      return { previousTodos, previousTodoDetail };\n    },\n    onError: (error, id, context) => {\n      toast.error(`Error deleting todo: ${error.message}`);\n      if (context?.previousTodos) {\n        queryClient.setQueryData(['todos', { filter, page, limit, search }], context.previousTodos);\n      }\n      if (context?.previousTodoDetail) {\n        queryClient.setQueryData(['todo', id], context.previousTodoDetail);\n      }\n    },\n    onSettled: () => {\n      queryClient.invalidateQueries({ queryKey: ['todos'] });\n    },\n  });\n\n  return {\n    todosQuery,\n    createTodoMutation,\n    updateTodoMutation,\n    deleteTodoMutation,\n    getTodoDetailsQuery,\n    ...todosQuery, // Spread all properties from todosQuery for convenience\n  };\n};\n\n### FILE: generated/web/hooks/useTheme.ts\n// This file is not strictly needed as `next-themes` provides `useTheme` directly.\n// It's included here for completeness if a custom hook wrapper was desired.\n// For this project, `next-themes/useTheme` is used directly in ThemeToggle.tsx.\n// If you wanted to add custom logic or context, this would be the place.\n\n// Example of a custom wrapper (not used in this project directly, but shows the pattern):\n/*\nimport { useTheme as useNextTheme } from 'next-themes';\nimport { useState, useEffect } from 'react';\n\nexport const useTheme = () => {\n  const [mounted, setMounted] = useState(false);\n  const { theme, setTheme, resolvedTheme } = useNextTheme();\n\n  useEffect(() => setMounted(true), []);\n\n  return {\n    theme,\n    setTheme,\n    resolvedTheme,\n    mounted,\n    isDarkMode: mounted && (theme === 'dark' || resolvedTheme === 'dark'),\n  };\n};\n*/\n\n### FILE: generated/web/hooks/useLocalStorage.ts\nimport { useState, useEffect, useCallback } from 'react';\n\ntype SetValue<T> = (value: T | ((prevValue: T) => T)) => void;\n\n/**\n * Custom hook for managing state in localStorage.\n *\n * @param key The key to store the value under in localStorage.\n * @param initialValue The initial value if nothing is found in localStorage.\n * @returns A tuple containing the current value and a setter function.\n */\nexport function useLocalStorage<T>(key: string, initialValue: T): [T, SetValue<T>] {\n  // State to store our value\n  // Pass initial state function to useState so logic is only executed once\n  const [storedValue, setStoredValue] = useState<T>(() => {\n    if (typeof window === 'undefined') {\n      return initialValue;\n    }\n    try {\n      // Get from local storage by key\n      const item = window.localStorage.getItem(key);\n      // Parse stored json or if none return initialValue\n      return item ? JSON.parse(item) : initialValue;\n    } catch (error) {\n      // If error also return initialValue\n      console.error(`Error reading localStorage key “${key}”:`, error);\n      return initialValue;\n    }\n  });\n\n  // Return a wrapped version of useState's setter function that persists the new value to localStorage.\n  const setValue: SetValue<T> = useCallback((value) => {\n    try {\n      // Allow value to be a function so we have same API as useState\n      const valueToStore = value instanceof Function ? value(storedValue) : value;\n      // Save state\n      setStoredValue(valueToStore);\n      // Save to local storage\n      if (typeof window !== 'undefined') {\n        window.localStorage.setItem(key, JSON.stringify(valueToStore));\n      }\n    } catch (error) {\n      console.error(`Error writing to localStorage key “${key}”:`, error);\n    }\n  }, [key, storedValue]); // Include storedValue in dependencies to ensure function receives latest state\n\n  // Optional: Sync state with localStorage changes from other tabs/windows\n  useEffect(() => {\n    const handleStorageChange = (event: StorageEvent) => {\n      if (event.key === key && event.newValue !== null) {\n        try {\n          setStoredValue(JSON.parse(event.newValue));\n        } catch (error) {\n          console.error(`Error parsing localStorage change for key “${key}”:`, error);\n        }\n      }\n    };\n\n    if (typeof window !== 'undefined') {\n      window.addEventListener('storage', handleStorageChange);\n    }\n\n    return () => {\n      if (typeof window !== 'undefined') {\n        window.removeEventListener('storage', handleStorageChange);\n      }\n    };\n  }, [key]);\n\n  return [storedValue, setValue];\n}\n\n### FILE: generated/web/lib/db.ts\nimport { promises as fs } from 'fs';\nimport path from 'path';\nimport { v4 as uuidv4 } from 'uuid';\nimport { Todo } from './types';\n\n// Path to the JSON file that simulates our database\nconst DATA_FILE_PATH = path.join(process.cwd(), 'data', 'todos.json');\n\n// Ensure the data directory exists\nasync function ensureDataDirectory() {\n  const dataDir = path.dirname(DATA_FILE_PATH);\n  try {\n    await fs.mkdir(dataDir, { recursive: true });\n  } catch (error) {\n    // Ignore if directory already exists\n    if ((error as NodeJS.ErrnoException).code !== 'EEXIST') {\n      console.error('Failed to create data directory:', error);\n      throw error;\n    }\n  }\n}\n\n// Read all todos from the JSON file\nasync function readTodos(): Promise<Todo[]> {\n  await ensureDataDirectory();\n  try {\n    const data = await fs.readFile(DATA_FILE_PATH, 'utf8');\n    return JSON.parse(data) as Todo[];\n  } catch (error) {\n    if ((error as NodeJS.ErrnoException).code === 'ENOENT') {\n      // File does not exist, return empty array\n      return [];\n    }\n    console.error('Error reading todos from file:', error);\n    throw new Error('Failed to read todos from database.');\n  }\n}\n\n// Write all todos to the JSON file\nasync function writeTodos(todos: Todo[]): Promise<void> {\n  await ensureDataDirectory();\n  try {\n    await fs.writeFile(DATA_FILE_PATH, JSON.stringify(todos, null, 2), 'utf8');\n  } catch (error) {\n    console.error('Error writing todos to file:', error);\n    throw new Error('Failed to write todos to database.');\n  }\n}\n\n// --- CRUD Operations ---\n\nexport async function getTodosFromDB(): Promise<Todo[]> {\n  const todos = await readTodos();\n  // Filter out soft-deleted items by default for most queries\n  return todos.filter(todo => !todo.deletedAt);\n}\n\nexport async function getTodoByIdFromDB(id: string): Promise<Todo | null> {\n  const todos = await readTodos();\n  const todo = todos.find(t => t.id === id && !t.deletedAt);\n  return todo || null;\n}\n\nexport async function createTodoInDB(newTodoData: Omit<Todo, 'id' | 'completed' | 'createdAt' | 'updatedAt' | 'deletedAt'>): Promise<Todo> {\n  const todos = await readTodos();\n  const now = new Date().toISOString();\n  const todo: Todo = {\n    id: uuidv4(),\n    title: newTodoData.title,\n    description: newTodoData.description || undefined,\n    completed: false,\n    dueDate: newTodoData.dueDate ? new Date(newTodoData.dueDate) : undefined,\n    createdAt: now,\n    updatedAt: now,\n    deletedAt: undefined,\n  };\n  todos.push(todo);\n  await writeTodos(todos);\n  return todo;\n}\n\nexport async function updateTodoInDB(id: string, updates: Partial<Omit<Todo, 'id' | 'createdAt' | 'deletedAt'>>): Promise<Todo | null> {\n  const todos = await readTodos();\n  const index = todos.findIndex(t => t.id === id && !t.deletedAt);\n\n  if (index === -1) {\n    return null;\n  }\n\n  const updatedTodo: Todo = {\n    ...todos[index],\n    ...updates,\n    updatedAt: new Date().toISOString(),\n    // Ensure dueDate is correctly handled if it's a string from API\n    dueDate: updates.dueDate ? new Date(updates.dueDate) : todos[index].dueDate,\n  };\n\n  todos[index] = updatedTodo;\n  await writeTodos(todos);\n  return updatedTodo;\n}\n\nexport async function softDeleteTodoInDB(id: string): Promise<Todo | null> {\n  const todos = await readTodos();\n  const index = todos.findIndex(t => t.id === id && !t.deletedAt);\n\n  if (index === -1) {\n    return null;\n  }\n\n  const deletedTodo: Todo = {\n    ...todos[index],\n    deletedAt: new Date().toISOString(),\n    updatedAt: new Date().toISOString(),\n  };\n\n  todos[index] = deletedTodo;\n  await writeTodos(todos);\n  return deletedTodo;\n}\n\n// Note on indexing: For a real database (e.g., PostgreSQL, MongoDB),\n// you would add indexes on fields like `userId` (if applicable, not in this spec),\n// `dueDate`, and `deletedAt` for efficient querying and filtering.\n// For this file-based simulation, indexing is not directly applicable.\n\n### FILE: generated/web/lib/types.ts\nexport interface Todo {\n  id: string;\n  title: string;\n  description?: string;\n  completed: boolean;\n  dueDate?: Date; // Stored as Date object in DB simulation, but can be string from API\n  createdAt: string; // ISO string\n  updatedAt: string; // ISO string\n  deletedAt?: string; // ISO string for soft delete\n}\n\nexport interface CreateTodoPayload {\n  title: string;\n  description?: string;\n  dueDate?: Date; // Can be Date object or ISO string\n}\n\nexport interface UpdateTodoPayload {\n  id: string;\n  title?: string;\n  description?: string;\n  completed?: boolean;\n  dueDate?: Date | null; // Null to clear due date\n}\n\nexport type TodoFilter = 'all' | 'active' | 'completed';\n\nexport interface PaginatedTodos {\n  todos: Todo[];\n  totalItems: number;\n  totalPages: number;\n  currentPage: number;\n  itemsPerPage: number;\n}\n\n### FILE: generated/web/lib/validation.ts\nimport { z } from 'zod';\nimport { isFuture, isToday, parseISO } from 'date-fns';\n\n// Helper function to validate date strings or Date objects\nconst dateSchema = z.preprocess((arg) => {\n  if (typeof arg === 'string') {\n    return parseISO(arg);\n  }\n  return arg;\n}, z.date().optional().nullable());\n\nexport const TodoSchema = z.object({\n  title: z\n    .string()\n    .trim()\n    .min(1, { message: 'Title cannot be empty.' })\n    .max(200, { message: 'Title cannot exceed 200 characters.' }),\n  description: z\n    .string()\n    .trim()\n    .max(500, { message: 'Description cannot exceed 500 characters.' })\n    .optional()\n    .nullable()\n    .transform(e => e === '' ? undefined : e), // Convert empty string to undefined\n  dueDate: dateSchema\n    .refine((date) => {\n      if (!date) return true; // Optional, so no validation if not provided\n      return isFuture(date) || isToday(date);\n    }, {\n      message: 'Due date must be today or in the future.',\n    })\n    .optional()\n    .nullable(),\n  completed: z.boolean().optional(),\n});\n\nexport const UpdateTodoSchema = TodoSchema.partial().extend({\n  id: z.string().uuid({ message: 'Invalid Todo ID format.' }),\n});\n\nexport const CreateTodoSchema = TodoSchema;\n\nexport const GetTodosQuerySchema = z.object({\n  status: z.enum(['all', 'active', 'completed']).default('all').optional(),\n  page: z.string().transform(Number).pipe(z.number().min(1)).default('1').optional(),\n  limit: z.string().transform(Number).pipe(z.number().min(1)).default('50').optional(),\n  search: z.string().trim().optional(),\n});\n\n### FILE: generated/web/lib/utils.ts\nimport { v4 as uuidv4 } from 'uuid';\nimport { format, isToday, isTomorrow, isPast } from 'date-fns';\n\n/**\n * Generates a UUID (Universally Unique Identifier).\n * @returns A new UUID string.\n */\nexport function generateUUID(): string {\n  return uuidv4();\n}\n\n/**\n * Formats a date into a human-readable string, with special labels for today/tomorrow/overdue.\n * @param date The date to format.\n * @returns A formatted date string or a special label.\n */\nexport function formatDueDate(date: Date | string | undefined): string | null {\n  if (!date) return null;\n\n  const d = typeof date === 'string' ? new Date(date) : date;\n\n  if (isToday(d)) return 'Today';\n  if (isTomorrow(d)) return 'Tomorrow';\n  if (isPast(d, new Date())) return 'Overdue';\n  return format(d, 'MMM d, yyyy');\n}\n\n// Utility for combining Tailwind classes\nimport { type ClassValue, clsx } from \"clsx\"\nimport { twMerge } from \"tailwind-merge\"\n\nexport function cn(...inputs: ClassValue[]) {\n  return twMerge(clsx(inputs))\n}\n\n### FILE: generated/web/lib/queryClient.ts\nimport { QueryClient } from '@tanstack/react-query';\n\nexport const queryClient = new QueryClient({\n  defaultOptions: {\n    queries: {\n      // Global staleTime for all queries (e.g., 5 minutes)\n      staleTime: 1000 * 60 * 5,\n      // Global cacheTime (how long unused/inactive query data remains in cache)\n      gcTime: 1000 * 60 * 60, // 1 hour\n      refetchOnWindowFocus: true, // Refetch data when window regains focus\n      refetchOnMount: true, // Refetch data when component mounts\n      refetchOnReconnect: true, // Refetch data when network reconnects\n      retry: 3, // Retry failed queries 3 times\n    },\n    mutations: {\n      // Global mutation options can be set here\n      // For example, a default onError handler\n      onError: (error) => {\n        console.error('Mutation error:', error);\n        // toast.error(`Something went wrong: ${error.message}`); // Handled in individual mutations for specific messages\n      },\n    },\n  },\n});\n\n### FILE: generated/web/lib/api.ts\ninterface RequestOptions extends RequestInit {\n  headers?: HeadersInit;\n}\n\nasync function handleResponse<T>(response: Response): Promise<T> {\n  if (!response.ok) {\n    let errorData: any;\n    try {\n      errorData = await response.json();\n    } catch {\n      errorData = { message: response.statusText };\n    }\n    throw new Error(errorData.message || 'An unexpected error occurred.');\n  }\n  return response.json();\n}\n\nexport const api = {\n  get: async <T>(url: string, options?: RequestOptions): Promise<T> => {\n    const response = await fetch(url, {\n      method: 'GET',\n      ...options,\n      headers: {\n        'Content-Type': 'application/json',\n        ...options?.headers,\n      },\n    });\n    return handleResponse<T>(response);\n  },\n\n  post: async <T>(url: string, data: any, options?: RequestOptions): Promise<T> => {\n    const response = await fetch(url, {\n      method: 'POST',\n      body: JSON.stringify(data),\n      ...options,\n      headers: {\n        'Content-Type': 'application/json',\n        ...options?.headers,\n      },\n    });\n    return handleResponse<T>(response);\n  },\n\n  put: async <T>(url: string, data: any, options?: RequestOptions): Promise<T> => {\n    const response = await fetch(url, {\n      method: 'PUT',\n      body: JSON.stringify(data),\n      ...options,\n      headers: {\n        'Content-Type': 'application/json',\n        ...options?.headers,\n      },\n    });\n    return handleResponse<T>(response);\n  },\n\n  delete: async <T>(url: string, options?: RequestOptions): Promise<T> => {\n    const response = await fetch(url, {\n      method: 'DELETE',\n      ...options,\n      headers: {\n        'Content-Type': 'application/json',\n        ...options?.headers,\n      },\n    });\n    return handleResponse<T>(response);\n  },\n};\n\n### FILE: generated/web/data/todos.json\n[]\n\n### FILE: generated/web/app/api/todos/route.ts\nimport { NextResponse } from 'next/server';\nimport { getTodosFromDB, createTodoInDB } from '@/lib/db';\nimport { CreateTodoSchema, GetTodosQuerySchema } from '@/lib/validation';\nimport { Todo, PaginatedTodos } from '@/lib/types';\n\n// GET /api/todos - Fetch all/filtered/paginated todos\nexport async function GET(request: Request) {\n  try {\n    const { searchParams } = new URL(request.url);\n    const query = Object.fromEntries(searchParams.entries());\n\n    // Validate query parameters\n    const parsedQuery = GetTodosQuerySchema.safeParse(query);\n\n    if (!parsedQuery.success) {\n      return NextResponse.json({ errors: parsedQuery.error.errors }, { status: 400 });\n    }\n\n    const { status, page, limit, search } = parsedQuery.data;\n\n    let todos = await getTodosFromDB();\n\n    // Apply search filter\n    if (search) {\n      const lowercasedSearch = search.toLowerCase();\n      todos = todos.filter(\n        (todo) =>\n          todo.title.toLowerCase().includes(lowercasedSearch) ||\n          (todo.description && todo.description.toLowerCase().includes(lowercasedSearch))\n      );\n    }\n\n    // Apply status filter\n    if (status === 'active') {\n      todos = todos.filter((todo) => !todo.completed);\n    } else if (status === 'completed') {\n      todos = todos.filter((todo) => todo.completed);\n    }\n\n    // Sort by createdAt descending (newest first)\n    todos.sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());\n\n    // Pagination\n    const totalItems = todos.length;\n    const totalPages = Math.ceil(totalItems / limit);\n    const startIndex = (page - 1) * limit;\n    const endIndex = startIndex + limit;\n    const paginatedTodos = todos.slice(startIndex, endIndex);\n\n    const response: PaginatedTodos = {\n      todos: paginatedTodos,\n      totalItems,\n      totalPages,\n      currentPage: page,\n      itemsPerPage: limit,\n    };\n\n    return NextResponse.json(response, { status: 200 });\n  } catch (error: any) {\n    console.error('API GET /api/todos error:', error);\n    return NextResponse.json({ message: error.message || 'Internal Server Error' }, { status: 500 });\n  }\n}\n\n// POST /api/todos - Create a new todo\nexport async function POST(request: Request) {\n  try {\n    const body = await request.json();\n\n    // Frontend validation is done, but backend validation is crucial\n    const parsedBody = CreateTodoSchema.safeParse(body);\n\n    if (!parsedBody.success) {\n      return NextResponse.json({ errors: parsedBody.error.errors }, { status: 400 });\n    }\n\n    const newTodoData = parsedBody.data;\n\n    const createdTodo = await createTodoInDB(newTodoData);\n\n    return NextResponse.json(createdTodo, { status: 201 });\n  } catch (error: any) {\n    console.error('API POST /api/todos error:', error);\n    return NextResponse.json({ message: error.message || 'Internal Server Error' }, { status: 500 });\n  }\n}\n\n### FILE: generated/web/app/api/todos/[id]/route.ts\nimport { NextResponse } from 'next/server';\nimport { getTodoByIdFromDB, updateTodoInDB, softDeleteTodoInDB } from '@/lib/db';\nimport { UpdateTodoSchema } from '@/lib/validation';\n\n// GET /api/todos/[id] - Fetch a single todo by ID\nexport async function GET(request: Request, { params }: { params: { id: string } }) {\n  try {\n    const { id } = params;\n    const todo = await getTodoByIdFromDB(id);\n\n    if (!todo) {\n      return NextResponse.json({ message: 'Todo not found' }, { status: 404 });\n    }\n\n    return NextResponse.json(todo, { status: 200 });\n  } catch (error: any) {\n    console.error(`API GET /api/todos/${params.id} error:`, error);\n    return NextResponse.json({ message: error.message || 'Internal Server Error' }, { status: 500 });\n  }\n}\n\n// PUT /api/todos/[id] - Update a todo by ID\nexport async function PUT(request: Request, { params }: { params: { id: string } }) {\n  try {\n    const { id } = params;\n    const body = await request.json();\n\n    // Validate incoming updates\n    const parsedBody = UpdateTodoSchema.safeParse({ ...body, id }); // Include ID for schema validation if needed\n\n    if (!parsedBody.success) {\n      return NextResponse.json({ errors: parsedBody.error.errors }, { status: 400 });\n    }\n\n    const updates = parsedBody.data;\n\n    const updatedTodo = await updateTodoInDB(id, updates);\n\n    if (!updatedTodo) {\n      return NextResponse.json({ message: 'Todo not found or already deleted' }, { status: 404 });\n    }\n\n    return NextResponse.json(updatedTodo, { status: 200 });\n  } catch (error: any) {\n    console.error(`API PUT /api/todos/${params.id} error:`, error);\n    return NextResponse.json({ message: error.message || 'Internal Server Error' }, { status: 500 });\n  }\n}\n\n// DELETE /api/todos/[id] - Soft delete a todo by ID\nexport async function DELETE(request: Request, { params }: { params: { id: string } }) {\n  try {\n    const { id } = params;\n    const deletedTodo = await softDeleteTodoInDB(id);\n\n    if (!deletedTodo) {\n      return NextResponse.json({ message: 'Todo not found or already deleted' }, { status: 404 });\n    }\n\n    return NextResponse.json({ message: 'Todo soft deleted successfully' }, { status: 200 });\n  } catch (error: any) {\n    console.error(`API DELETE /api/todos/${params.id} error:`, error);\n    return NextResponse.json({ message: error.message || 'Internal Server"
}