{
  "205791a29544ae44bc9351f92de1f363b860532f42d1fa5b5cb907e19909723b": "### FILE: package.json\n{\n  \"name\": \"web\",\n  \"version\": \"0.1.0\",\n  \"private\": true,\n  \"scripts\": {\n    \"dev\": \"next dev\",\n    \"build\": \"next build\",\n    \"start\": \"next start\",\n    \"lint\": \"next lint\"\n  },\n  \"dependencies\": {\n    \"@react-aria/focus\": \"^3.16.0\",\n    \"@react-aria/interactions\": \"^3.19.0\",\n    \"@react-aria/overlays\": \"^3.17.0\",\n    \"@react-stately/collections\": \"^3.8.0\",\n    \"@react-stately/overlays\": \"^3.6.0\",\n    \"@types/node\": \"20.14.9\",\n    \"@types/react\": \"18.3.3\",\n    \"@types/react-dom\": \"18.3.0\",\n    \"@types/uuid\": \"^9.0.8\",\n    \"autoprefixer\": \"10.4.19\",\n    \"clsx\": \"^2.1.1\",\n    \"date-fns\": \"^3.6.0\",\n    \"eslint\": \"8.57.0\",\n    \"eslint-config-next\": \"14.2.4\",\n    \"localforage\": \"^1.10.0\",\n    \"next\": \"14.2.4\",\n    \"postcss\": \"8.4.39\",\n    \"react\": \"18.3.1\",\n    \"react-debounce-input\": \"^3.3.0\",\n    \"react-dom\": \"18.3.1\",\n    \"tailwind-merge\": \"^2.3.0\",\n    \"tailwindcss\": \"3.4.4\",\n    \"typescript\": \"5.5.3\",\n    \"uuid\": \"^10.0.0\",\n    \"zod\": \"^3.23.8\"\n  }\n}\n\n### FILE: tsconfig.json\n{\n  \"compilerOptions\": {\n    \"lib\": [\"dom\", \"dom.iterable\", \"esnext\"],\n    \"allowJs\": true,\n    \"skipLibCheck\": true,\n    \"strict\": true,\n    \"noEmit\": true,\n    \"esModuleInterop\": true,\n    \"module\": \"esnext\",\n    \"moduleResolution\": \"bundler\",\n    \"resolveJsonModule\": true,\n    \"isolatedModules\": true,\n    \"jsx\": \"preserve\",\n    \"incremental\": true,\n    \"plugins\": [\n      {\n        \"name\": \"next\"\n      }\n    ],\n    \"paths\": {\n      \"@/*\": [\"./*\"]\n    }\n  },\n  \"include\": [\"next-env.d.ts\", \"**/*.ts\", \"**/*.tsx\", \".next/types/**/*.ts\"],\n  \"exclude\": [\"node_modules\"]\n}\n\n### FILE: next.config.js\n/** @type {import('next').NextConfig} */\nconst nextConfig = {\n  reactStrictMode: true,\n};\n\nmodule.exports = nextConfig;\n\n### FILE: postcss.config.js\nmodule.exports = {\n  plugins: {\n    tailwindcss: {},\n    autoprefixer: {},\n  },\n};\n\n### FILE: tailwind.config.ts\nimport type { Config } from 'tailwindcss';\n\nconst config: Config = {\n  darkMode: 'class', // Enable dark mode based on 'class'\n  content: [\n    './pages/**/*.{js,ts,jsx,tsx,mdx}',\n    './components/**/*.{js,ts,jsx,tsx,mdx}',\n    './app/**/*.{js,ts,jsx,tsx,mdx}',\n  ],\n  theme: {\n    extend: {\n      colors: {\n        primary: {\n          50: '#eef2ff',\n          100: '#e0e7ff',\n          200: '#c7d2fe',\n          300: '#a5b4fc',\n          400: '#818cf8',\n          500: '#6366f1', // Main blue/indigo\n          600: '#4f46e5',\n          700: '#4338ca',\n          800: '#3730a3',\n          900: '#312e81',\n          950: '#1e1b4b',\n        },\n        secondary: {\n          50: '#f0f9ff',\n          100: '#e0f2fe',\n          200: '#bae6fd',\n          300: '#7dd3fc',\n          400: '#38bdf8',\n          500: '#0ea5e9',\n          600: '#0284c7',\n          700: '#0369a1',\n          800: '#075985',\n          900: '#0c4a6e',\n          950: '#082f49',\n        },\n      },\n      boxShadow: {\n        'subtle': '0 4px 6px -1px rgba(0, 0, 0, 0.05), 0 2px 4px -1px rgba(0, 0, 0, 0.03)',\n        'card': '0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05)',\n        'card-hover': '0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04)',\n      },\n    },\n  },\n  plugins: [],\n};\n\n### FILE: .env.local\n# This is a placeholder for environment variables.\n# For a real database, you would put your DATABASE_URL here.\n# For this example, we're using a file-based JSON DB, so no external DB URL is needed.\n# NEXT_PUBLIC_API_BASE_URL=http://localhost:3000/api\n\n### FILE: app/layout.tsx\nimport type { Metadata } from 'next';\nimport { Inter } from 'next/font/google';\nimport './globals.css';\nimport { DarkModeProvider } from '@/hooks/useDarkMode';\nimport { cn } from '@/lib/utils';\n\nconst inter = Inter({ subsets: ['latin'] });\n\nexport const metadata: Metadata = {\n  title: 'Next.js Todo App',\n  description: 'A production-ready Todo application built with Next.js and TypeScript.',\n};\n\nexport default function RootLayout({\n  children,\n}: Readonly<{\n  children: React.ReactNode;\n}>) {\n  return (\n    <html lang=\"en\" suppressHydrationWarning>\n      <body\n        className={cn(\n          inter.className,\n          'bg-gray-50 text-gray-900 dark:bg-gray-900 dark:text-gray-50 transition-colors duration-300'\n        )}\n      >\n        <DarkModeProvider>{children}</DarkModeProvider>\n      </body>\n    </html>\n  );\n}\n\n### FILE: app/globals.css\n@tailwind base;\n@tailwind components;\n@tailwind utilities;\n\n@layer base {\n  :root {\n    --foreground-rgb: 0, 0, 0;\n    --background-start-rgb: 255, 255, 255;\n    --background-end-rgb: 255, 255, 255;\n  }\n\n  @media (prefers-color-scheme: dark) {\n    :root {\n      --foreground-rgb: 255, 255, 255;\n      --background-start-rgb: 0, 0, 0;\n      --background-end-rgb: 0, 0, 0;\n    }\n  }\n\n  body {\n    color: rgb(var(--foreground-rgb));\n    background: linear-gradient(\n        to bottom,\n        transparent,\n        rgb(var(--background-end-rgb))\n      )\n      rgb(var(--background-start-rgb));\n  }\n}\n\n/* Custom focus styles for accessibility */\n*:focus-visible {\n  outline: 2px solid theme('colors.primary.500');\n  outline-offset: 2px;\n  border-radius: theme('borderRadius.md'); /* Match card/button radius */\n}\n\n### FILE: app/page.tsx\n'use client';\n\nimport { useState } from 'react';\nimport { TodoForm } from '@/components/TodoForm';\nimport { TodoList } from '@/components/TodoList';\nimport { FilterButtons } from '@/components/FilterButtons';\nimport { Pagination } from '@/components/Pagination';\nimport { DarkModeToggle } from '@/components/DarkModeToggle';\nimport { useTodos } from '@/hooks/useTodos';\nimport { TodoFilter } from '@/types';\nimport { DebounceInput } from 'react-debounce-input';\nimport { cn } from '@/lib/utils';\n\nexport default function Home() {\n  const [filter, setFilter] = useState<TodoFilter>('all');\n  const [page, setPage] = useState(1);\n  const [searchQuery, setSearchQuery] = useState('');\n\n  const { todos, isLoading, error, totalPages, addTodo, updateTodo, deleteTodo } = useTodos({\n    filter,\n    page,\n    limit: 50, // 50 todos per page as per spec\n    searchQuery,\n  });\n\n  return (\n    <div className=\"min-h-screen flex flex-col items-center py-8 px-4 sm:px-6 lg:px-8\">\n      <div className=\"w-full max-w-4xl space-y-8\">\n        <div className=\"flex justify-between items-center mb-8\">\n          <h1 className=\"text-4xl font-extrabold text-primary-700 dark:text-primary-300\">\n            Todo App\n          </h1>\n          <DarkModeToggle />\n        </div>\n\n        {/* Todo Creation Form */}\n        <TodoForm onSubmit={addTodo} />\n\n        {/* Filters and Search */}\n        <div className=\"flex flex-col sm:flex-row justify-between items-center gap-4 mt-8\">\n          <FilterButtons currentFilter={filter} onFilterChange={setFilter} />\n          <DebounceInput\n            minLength={1}\n            debounceTimeout={300}\n            onChange={(e) => setSearchQuery(e.target.value)}\n            value={searchQuery}\n            placeholder=\"Search todos...\"\n            aria-label=\"Search todos\"\n            className={cn(\n              'w-full sm:w-auto px-4 py-2 border rounded-md shadow-sm',\n              'bg-white dark:bg-gray-800 border-gray-300 dark:border-gray-700',\n              'text-gray-900 dark:text-gray-100',\n              'focus:ring-primary-500 focus:border-primary-500'\n            )}\n          />\n        </div>\n\n        {/* Todo List */}\n        {isLoading && (\n          <div className=\"text-center text-lg text-gray-600 dark:text-gray-400\">Loading todos...</div>\n        )}\n        {error && (\n          <div className=\"text-center text-red-600 dark:text-red-400\">Error: {error}</div>\n        )}\n        {!isLoading && !error && todos.length === 0 && (\n          <div className=\"text-center text-lg text-gray-600 dark:text-gray-400\">\n            No todos found. Try adding one!\n          </div>\n        )}\n        {!isLoading && !error && todos.length > 0 && (\n          <TodoList todos={todos} onUpdate={updateTodo} onDelete={deleteTodo} />\n        )}\n\n        {/* Pagination */}\n        {totalPages > 1 && (\n          <Pagination currentPage={page} totalPages={totalPages} onPageChange={setPage} />\n        )}\n      </div>\n    </div>\n  );\n}\n\n### FILE: app/api/todos/route.ts\nimport { NextResponse } from 'next/server';\nimport { getTodos, addTodo, updateTodo, deleteTodoSoft } from '@/lib/db';\nimport { todoSchema, updateTodoSchema } from '@/lib/validation';\nimport { v4 as uuidv4 } from 'uuid';\nimport { isFuture, isToday, parseISO } from 'date-fns';\n\n// Helper to handle Zod validation errors\nconst handleValidationError = (error: any) => {\n  return NextResponse.json({ message: 'Validation Error', errors: error.errors }, { status: 400 });\n};\n\n// GET /api/todos\nexport async function GET(request: Request) {\n  try {\n    const { searchParams } = new URL(request.url);\n    const filter = searchParams.get('filter') as 'all' | 'active' | 'completed' | null;\n    const page = parseInt(searchParams.get('page') || '1', 10);\n    const limit = parseInt(searchParams.get('limit') || '50', 10);\n    const searchQuery = searchParams.get('searchQuery') || '';\n\n    const { todos, totalPages } = await getTodos({ filter, page, limit, searchQuery });\n    return NextResponse.json({ todos, totalPages });\n  } catch (error) {\n    console.error('Failed to fetch todos:', error);\n    return NextResponse.json({ message: 'Failed to fetch todos' }, { status: 500 });\n  }\n}\n\n// POST /api/todos\nexport async function POST(request: Request) {\n  try {\n    const body = await request.json();\n    const parsedBody = todoSchema.parse(body);\n\n    // Backend specific due date validation\n    if (parsedBody.dueDate) {\n      const dueDate = parseISO(parsedBody.dueDate);\n      if (!isToday(dueDate) && !isFuture(dueDate)) {\n        return NextResponse.json(\n          { message: 'Validation Error', errors: [{ path: ['dueDate'], message: 'Due date must be today or in the future.' }] },\n          { status: 400 }\n        );\n      }\n    }\n\n    const newTodo = {\n      id: uuidv4(),\n      title: parsedBody.title.trim(),\n      completed: false,\n      dueDate: parsedBody.dueDate || null,\n      createdAt: new Date().toISOString(),\n      updatedAt: new Date().toISOString(),\n      deletedAt: null,\n      userId: 'user-123', // Hardcoded for this example as user auth is not in scope\n    };\n\n    const addedTodo = await addTodo(newTodo);\n    return NextResponse.json(addedTodo, { status: 201 });\n  } catch (error: any) {\n    if (error.name === 'ZodError') {\n      return handleValidationError(error);\n    }\n    console.error('Failed to create todo:', error);\n    return NextResponse.json({ message: 'Failed to create todo' }, { status: 500 });\n  }\n}\n\n// PUT /api/todos/[id] (for marking complete/incomplete)\nexport async function PUT(request: Request) {\n  try {\n    const { searchParams } = new URL(request.url);\n    const id = searchParams.get('id');\n    if (!id) {\n      return NextResponse.json({ message: 'Todo ID is required' }, { status: 400 });\n    }\n\n    const body = await request.json();\n    const parsedBody = updateTodoSchema.parse(body);\n\n    const updatedTodo = await updateTodo(id, parsedBody);\n    if (!updatedTodo) {\n      return NextResponse.json({ message: 'Todo not found' }, { status: 404 });\n    }\n    return NextResponse.json(updatedTodo);\n  } catch (error: any) {\n    if (error.name === 'ZodError') {\n      return handleValidationError(error);\n    }\n    console.error('Failed to update todo:', error);\n    return NextResponse.json({ message: 'Failed to update todo' }, { status: 500 });\n  }\n}\n\n// DELETE /api/todos/[id] (soft delete)\nexport async function DELETE(request: Request) {\n  try {\n    const { searchParams } = new URL(request.url);\n    const id = searchParams.get('id');\n    if (!id) {\n      return NextResponse.json({ message: 'Todo ID is required' }, { status: 400 });\n    }\n\n    const deletedTodo = await deleteTodoSoft(id);\n    if (!deletedTodo) {\n      return NextResponse.json({ message: 'Todo not found' }, { status: 404 });\n    }\n    return NextResponse.json({ message: 'Todo soft-deleted successfully' });\n  } catch (error) {\n    console.error('Failed to soft-delete todo:', error);\n    return NextResponse.json({ message: 'Failed to soft-delete todo' }, { status: 500 });\n  }\n}\n\n### FILE: app/api/todos/[id]/route.ts\nimport { NextResponse } from 'next/server';\nimport { updateTodo, deleteTodoSoft } from '@/lib/db';\nimport { updateTodoSchema } from '@/lib/validation';\nimport { isFuture, isToday, parseISO } from 'date-fns';\n\n// Helper to handle Zod validation errors\nconst handleValidationError = (error: any) => {\n  return NextResponse.json({ message: 'Validation Error', errors: error.errors }, { status: 400 });\n};\n\n// PUT /api/todos/[id] (for marking complete/incomplete or updating title/dueDate)\nexport async function PUT(request: Request, { params }: { params: { id: string } }) {\n  try {\n    const id = params.id;\n    const body = await request.json();\n    const parsedBody = updateTodoSchema.parse(body);\n\n    // Backend specific due date validation if dueDate is being updated\n    if (parsedBody.dueDate) {\n      const dueDate = parseISO(parsedBody.dueDate);\n      if (!isToday(dueDate) && !isFuture(dueDate)) {\n        return NextResponse.json(\n          { message: 'Validation Error', errors: [{ path: ['dueDate'], message: 'Due date must be today or in the future.' }] },\n          { status: 400 }\n        );\n      }\n    }\n\n    const updatedTodo = await updateTodo(id, parsedBody);\n    if (!updatedTodo) {\n      return NextResponse.json({ message: 'Todo not found' }, { status: 404 });\n    }\n    return NextResponse.json(updatedTodo);\n  } catch (error: any) {\n    if (error.name === 'ZodError') {\n      return handleValidationError(error);\n    }\n    console.error(`Failed to update todo ${params.id}:`, error);\n    return NextResponse.json({ message: 'Failed to update todo' }, { status: 500 });\n  }\n}\n\n// DELETE /api/todos/[id] (soft delete)\nexport async function DELETE(request: Request, { params }: { params: { id: string } }) {\n  try {\n    const id = params.id;\n    const deletedTodo = await deleteTodoSoft(id);\n    if (!deletedTodo) {\n      return NextResponse.json({ message: 'Todo not found' }, { status: 404 });\n    }\n    return NextResponse.json({ message: 'Todo soft-deleted successfully' });\n  } catch (error) {\n    console.error(`Failed to soft-delete todo ${params.id}:`, error);\n    return NextResponse.json({ message: 'Failed to soft-delete todo' }, { status: 500 });\n  }\n}\n\n### FILE: components/DarkModeToggle.tsx\n'use client';\n\nimport { useDarkMode } from '@/hooks/useDarkMode';\nimport { SunIcon, MoonIcon } from './Icons'; // Assuming you'll create these icons\n\nexport function DarkModeToggle() {\n  const { isDarkMode, toggleDarkMode } = useDarkMode();\n\n  return (\n    <button\n      onClick={toggleDarkMode}\n      className=\"p-2 rounded-full bg-gray-200 dark:bg-gray-700 text-gray-800 dark:text-gray-200\n                 hover:bg-gray-300 dark:hover:bg-gray-600 transition-colors duration-200\n                 focus:outline-none focus-visible:ring-2 focus-visible:ring-primary-500 focus-visible:ring-offset-2\n                 flex items-center justify-center\"\n      aria-label={isDarkMode ? 'Switch to light mode' : 'Switch to dark mode'}\n    >\n      {isDarkMode ? (\n        <SunIcon className=\"h-5 w-5\" />\n      ) : (\n        <MoonIcon className=\"h-5 w-5\" />\n      )}\n    </button>\n  );\n}\n\n### FILE: components/DebouncedInput.tsx\n// This component is not strictly needed as react-debounce-input is used directly in app/page.tsx\n// However, if more complex styling or logic were needed, it would be here.\n// For now, it's just a placeholder to show where it *could* be.\nimport React from 'react';\nimport { DebounceInput } from 'react-debounce-input';\nimport { cn } from '@/lib/utils';\n\ninterface DebouncedInputProps extends React.InputHTMLAttributes<HTMLInputElement> {\n  minLength?: number;\n  debounceTimeout?: number;\n}\n\nexport const CustomDebouncedInput = React.forwardRef<HTMLInputElement, DebouncedInputProps>(\n  ({ className, minLength = 1, debounceTimeout = 300, ...props }, ref) => {\n    return (\n      <DebounceInput\n        minLength={minLength}\n        debounceTimeout={debounceTimeout}\n        element=\"input\"\n        className={cn(\n          'w-full px-4 py-2 border rounded-md shadow-sm',\n          'bg-white dark:bg-gray-800 border-gray-300 dark:border-gray-700',\n          'text-gray-900 dark:text-gray-100',\n          'focus:ring-primary-500 focus:border-primary-500',\n          className\n        )}\n        inputRef={ref}\n        {...props}\n      />\n    );\n  }\n);\n\nCustomDebouncedInput.displayName = 'CustomDebouncedInput';\n\n### FILE: components/FilterButtons.tsx\nimport { TodoFilter } from '@/types';\nimport { cn } from '@/lib/utils';\n\ninterface FilterButtonsProps {\n  currentFilter: TodoFilter;\n  onFilterChange: (filter: TodoFilter) => void;\n}\n\nexport function FilterButtons({ currentFilter, onFilterChange }: FilterButtonsProps) {\n  const filters: { label: string; value: TodoFilter }[] = [\n    { label: 'All', value: 'all' },\n    { label: 'Active', value: 'active' },\n    { label: 'Completed', value: 'completed' },\n  ];\n\n  return (\n    <div className=\"flex space-x-2 p-1 rounded-lg bg-gray-100 dark:bg-gray-800 shadow-inner\">\n      {filters.map((filter) => (\n        <button\n          key={filter.value}\n          onClick={() => onFilterChange(filter.value)}\n          className={cn(\n            'px-4 py-2 rounded-md text-sm font-medium transition-colors duration-200',\n            'focus:outline-none focus-visible:ring-2 focus-visible:ring-primary-500 focus-visible:ring-offset-2',\n            currentFilter === filter.value\n              ? 'bg-primary-500 text-white shadow-md'\n              : 'text-gray-700 dark:text-gray-300 hover:bg-gray-200 dark:hover:bg-gray-700'\n          )}\n          aria-pressed={currentFilter === filter.value}\n          aria-label={`Show ${filter.label} todos`}\n        >\n          {filter.label}\n        </button>\n      ))}\n    </div>\n  );\n}\n\n### FILE: components/Icons.tsx\nimport React from 'react';\n\ninterface IconProps extends React.SVGProps<SVGSVGElement> {\n  className?: string;\n}\n\nexport const SunIcon: React.FC<IconProps> = (props) => (\n  <svg\n    xmlns=\"http://www.w3.org/2000/svg\"\n    fill=\"none\"\n    viewBox=\"0 0 24 24\"\n    strokeWidth={1.5}\n    stroke=\"currentColor\"\n    {...props}\n  >\n    <path\n      strokeLinecap=\"round\"\n      strokeLinejoin=\"round\"\n      d=\"M12 3v2.25m6.364.386l-1.591 1.591M21 12h-2.25m-.386 6.364l-1.591-1.591M12 18.75V21m-4.364-.386l1.591-1.591M3 12h2.25m.386-6.364l1.591 1.591M12 12a2.25 2.25 0 100-4.5 2.25 2.25 0 000 4.5z\"\n    />\n  </svg>\n);\n\nexport const MoonIcon: React.FC<IconProps> = (props) => (\n  <svg\n    xmlns=\"http://www.w3.org/2000/svg\"\n    fill=\"none\"\n    viewBox=\"0 0 24 24\"\n    strokeWidth={1.5}\n    stroke=\"currentColor\"\n    {...props}\n  >\n    <path\n      strokeLinecap=\"round\"\n      strokeLinejoin=\"round\"\n      d=\"M21.752 15.002A9.718 9.718 0 0112 21.75c-3.61 0-6.91-1.543-9.252-4.002M2.25 9.75a9.718 9.718 0 019.75-7.75c3.61 0 6.91 1.543 9.252 4.002\"\n    />\n  </svg>\n);\n\nexport const PlusIcon: React.FC<IconProps> = (props) => (\n  <svg\n    xmlns=\"http://www.w3.org/2000/svg\"\n    fill=\"none\"\n    viewBox=\"0 0 24 24\"\n    strokeWidth={1.5}\n    stroke=\"currentColor\"\n    {...props}\n  >\n    <path strokeLinecap=\"round\" strokeLinejoin=\"round\" d=\"M12 4.5v15m7.5-7.5h-15\" />\n  </svg>\n);\n\nexport const TrashIcon: React.FC<IconProps> = (props) => (\n  <svg\n    xmlns=\"http://www.w3.org/2000/svg\"\n    fill=\"none\"\n    viewBox=\"0 0 24 24\"\n    strokeWidth={1.5}\n    stroke=\"currentColor\"\n    {...props}\n  >\n    <path\n      strokeLinecap=\"round\"\n      strokeLinejoin=\"round\"\n      d=\"M14.74 9l-.346 9m-4.788 0L9.26 9m9.968-3.21c.342.052.682.107 1.022.166m-1.022-.165L18.16 19.673a2.25 2.25 0 01-2.244 2.077H8.927a2.25 2.25 0 01-2.244-2.077L4.772 5.79m14.456 0a48.108 48.108 0 00-3.478-.397m-12 .562c.34-.059.68-.114 1.022-.165m0 0a48.11 48.11 0 013.478-.397m7.5 0v-.916c0-1.18-.91-2.14-2.006-2.293a1.5 1.5 0 00-1.485 1.647l.346 1.17m-5.115-1.17a1.5 1.5 0 00-1.485-1.647c-1.096.153-2.006 1.113-2.006 2.293v.916m7.5 0a48.667 48.667 0 00-7.5 0\"\n    />\n  </svg>\n);\n\nexport const ChevronLeftIcon: React.FC<IconProps> = (props) => (\n  <svg\n    xmlns=\"http://www.w3.org/2000/svg\"\n    fill=\"none\"\n    viewBox=\"0 0 24 24\"\n    strokeWidth={1.5}\n    stroke=\"currentColor\"\n    {...props}\n  >\n    <path strokeLinecap=\"round\" strokeLinejoin=\"round\" d=\"M15.75 19.5L8.25 12l7.5-7.5\" />\n  </svg>\n);\n\nexport const ChevronRightIcon: React.FC<IconProps> = (props) => (\n  <svg\n    xmlns=\"http://www.w3.org/2000/svg\"\n    fill=\"none\"\n    viewBox=\"0 0 24 24\"\n    strokeWidth={1.5}\n    stroke=\"currentColor\"\n    {...props}\n  >\n    <path strokeLinecap=\"round\" strokeLinejoin=\"round\" d=\"M8.25 4.5l7.5 7.5-7.5 7.5\" />\n  </svg>\n);\n\nexport const XMarkIcon: React.FC<IconProps> = (props) => (\n  <svg\n    xmlns=\"http://www.w3.org/2000/svg\"\n    fill=\"none\"\n    viewBox=\"0 0 24 24\"\n    strokeWidth={1.5}\n    stroke=\"currentColor\"\n    {...props}\n  >\n    <path strokeLinecap=\"round\" strokeLinejoin=\"round\" d=\"M6 18L18 6M6 6l12 12\" />\n  </svg>\n);\n\n### FILE: components/LoadingSpinner.tsx\nimport React from 'react';\n\ninterface LoadingSpinnerProps {\n  className?: string;\n}\n\nexport const LoadingSpinner: React.FC<LoadingSpinnerProps> = ({ className }) => {\n  return (\n    <div className={`flex justify-center items-center ${className}`}>\n      <div\n        className=\"animate-spin rounded-full h-8 w-8 border-b-2 border-primary-500\"\n        role=\"status\"\n        aria-label=\"Loading\"\n      >\n        <span className=\"sr-only\">Loading...</span>\n      </div>\n    </div>\n  );\n};\n\n### FILE: components/Modal.tsx\n'use client';\n\nimport React, { useRef, useEffect, useCallback } from 'react';\nimport { useOverlay, useModal, usePreventScroll, useOverlayTrigger } from 'react-aria';\nimport { OverlayContainer } from '@react-aria/overlays';\nimport { XMarkIcon } from './Icons';\nimport { cn } from '@/lib/utils';\n\ninterface ModalProps {\n  isOpen: boolean;\n  onClose: () => void;\n  title: string;\n  children: React.ReactNode;\n  className?: string;\n}\n\nexport function Modal({ isOpen, onClose, title, children, className }: ModalProps) {\n  const ref = useRef<HTMLDivElement>(null);\n  const { modalProps } = useModal();\n  const { overlayProps } = useOverlay({ onClose, isOpen, isDismissable: true }, ref);\n  usePreventScroll({ isDisabled: !isOpen });\n\n  const handleKeyDown = useCallback(\n    (e: KeyboardEvent) => {\n      if (e.key === 'Escape') {\n        onClose();\n      }\n    },\n    [onClose]\n  );\n\n  useEffect(() => {\n    if (isOpen) {\n      document.addEventListener('keydown', handleKeyDown);\n    } else {\n      document.removeEventListener('keydown', handleKeyDown);\n    }\n    return () => {\n      document.removeEventListener('keydown', handleKeyDown);\n    };\n  }, [isOpen, handleKeyDown]);\n\n  if (!isOpen) {\n    return null;\n  }\n\n  return (\n    <OverlayContainer>\n      <div className=\"fixed inset-0 z-50 flex items-center justify-center p-4\">\n        {/* Backdrop */}\n        <div\n          className=\"fixed inset-0 bg-black bg-opacity-50 dark:bg-opacity-70 backdrop-blur-sm\"\n          aria-hidden=\"true\"\n          onClick={onClose}\n        />\n\n        {/* Modal Content */}\n        <div\n          {...overlayProps}\n          {...modalProps}\n          ref={ref}\n          className={cn(\n            'relative bg-white dark:bg-gray-800 rounded-lg shadow-card-hover max-w-lg w-full p-6',\n            'transform transition-all duration-300 ease-out scale-100 opacity-100', // For initial animation\n            'focus:outline-none focus-visible:ring-2 focus-visible:ring-primary-500 focus-visible:ring-offset-2',\n            className\n          )}\n          role=\"dialog\"\n          aria-modal=\"true\"\n          aria-labelledby=\"modal-title\"\n        >\n          <div className=\"flex justify-between items-center mb-4 border-b pb-3 border-gray-200 dark:border-gray-700\">\n            <h2 id=\"modal-title\" className=\"text-xl font-semibold text-gray-900 dark:text-gray-100\">\n              {title}\n            </h2>\n            <button\n              onClick={onClose}\n              className=\"p-1 rounded-full text-gray-500 hover:bg-gray-100 dark:hover:bg-gray-700\n                         focus:outline-none focus-visible:ring-2 focus-visible:ring-primary-500 focus-visible:ring-offset-2\"\n              aria-label=\"Close modal\"\n            >\n              <XMarkIcon className=\"h-5 w-5\" />\n            </button>\n          </div>\n          <div className=\"text-gray-700 dark:text-gray-300\">{children}</div>\n        </div>\n      </div>\n    </OverlayContainer>\n  );\n}\n\n### FILE: components/Pagination.tsx\nimport { ChevronLeftIcon, ChevronRightIcon } from './Icons';\nimport { cn } from '@/lib/utils';\n\ninterface PaginationProps {\n  currentPage: number;\n  totalPages: number;\n  onPageChange: (page: number) => void;\n}\n\nexport function Pagination({ currentPage, totalPages, onPageChange }: PaginationProps) {\n  if (totalPages <= 1) return null;\n\n  const pages = Array.from({ length: totalPages }, (_, i) => i + 1);\n\n  return (\n    <nav className=\"flex justify-center items-center space-x-2 mt-8\" aria-label=\"Pagination\">\n      <button\n        onClick={() => onPageChange(currentPage - 1)}\n        disabled={currentPage === 1}\n        className={cn(\n          'p-2 rounded-md transition-colors duration-200',\n          'bg-gray-100 dark:bg-gray-800 text-gray-700 dark:text-gray-300',\n          'hover:bg-gray-200 dark:hover:bg-gray-700',\n          'disabled:opacity-50 disabled:cursor-not-allowed',\n          'focus:outline-none focus-visible:ring-2 focus-visible:ring-primary-500 focus-visible:ring-offset-2'\n        )}\n        aria-label=\"Previous page\"\n      >\n        <ChevronLeftIcon className=\"h-5 w-5\" />\n      </button>\n\n      {pages.map((pageNumber) => (\n        <button\n          key={pageNumber}\n          onClick={() => onPageChange(pageNumber)}\n          className={cn(\n            'px-4 py-2 rounded-md text-sm font-medium transition-colors duration-200',\n            'focus:outline-none focus-visible:ring-2 focus-visible:ring-primary-500 focus-visible:ring-offset-2',\n            pageNumber === currentPage\n              ? 'bg-primary-500 text-white shadow-md'\n              : 'bg-gray-100 dark:bg-gray-800 text-gray-700 dark:text-gray-300 hover:bg-gray-200 dark:hover:bg-gray-700'\n          )}\n          aria-current={pageNumber === currentPage ? 'page' : undefined}\n          aria-label={`Page ${pageNumber}`}\n        >\n          {pageNumber}\n        </button>\n      ))}\n\n      <button\n        onClick={() => onPageChange(currentPage + 1)}\n        disabled={currentPage === totalPages}\n        className={cn(\n          'p-2 rounded-md transition-colors duration-200',\n          'bg-gray-100 dark:bg-gray-800 text-gray-700 dark:text-gray-300',\n          'hover:bg-gray-200 dark:hover:bg-gray-700',\n          'disabled:opacity-50 disabled:cursor-not-allowed',\n          'focus:outline-none focus-visible:ring-2 focus-visible:ring-primary-500 focus-visible:ring-offset-2'\n        )}\n        aria-label=\"Next page\"\n      >\n        <ChevronRightIcon className=\"h-5 w-5\" />\n      </button>\n    </nav>\n  );\n}\n\n### FILE: components/TodoForm.tsx\n'use client';\n\nimport React, { useState } from 'react';\nimport { TodoInput } from '@/types';\nimport { format } from 'date-fns';\nimport { todoInputSchema } from '@/lib/validation';\nimport { PlusIcon } from './Icons';\nimport { cn } from '@/lib/utils';\n\ninterface TodoFormProps {\n  onSubmit: (todo: TodoInput) => Promise<void>;\n}\n\nexport function TodoForm({ onSubmit }: TodoFormProps) {\n  const [title, setTitle] = useState('');\n  const [dueDate, setDueDate] = useState('');\n  const [errors, setErrors] = useState<{ title?: string; dueDate?: string }>({});\n  const [isSubmitting, setIsSubmitting] = useState(false);\n\n  const handleSubmit = async (e: React.FormEvent) => {\n    e.preventDefault();\n    setErrors({});\n    setIsSubmitting(true);\n\n    try {\n      const validatedData = todoInputSchema.parse({\n        title: title.trim(),\n        dueDate: dueDate || undefined,\n      });\n\n      await onSubmit({\n        title: validatedData.title,\n        dueDate: validatedData.dueDate,\n      });\n      setTitle('');\n      setDueDate('');\n    } catch (error: any) {\n      if (error.name === 'ZodError') {\n        const newErrors: { title?: string; dueDate?: string } = {};\n        error.errors.forEach((err: any) => {\n          if (err.path.includes('title')) newErrors.title = err.message;\n          if (err.path.includes('dueDate')) newErrors.dueDate = err.message;\n        });\n        setErrors(newErrors);\n      } else {\n        console.error('Failed to add todo:', error);\n        setErrors({ title: 'An unexpected error occurred.' });\n      }\n    } finally {\n      setIsSubmitting(false);\n    }\n  };\n\n  const today = format(new Date(), 'yyyy-MM-dd');\n\n  return (\n    <form\n      onSubmit={handleSubmit}\n      className=\"flex flex-col sm:flex-row gap-4 p-6 bg-white dark:bg-gray-800 rounded-lg shadow-card\"\n      aria-label=\"Add new todo\"\n    >\n      <div className=\"flex-grow\">\n        <label htmlFor=\"todo-title\" className=\"sr-only\">\n          Todo Title\n        </label>\n        <input\n          id=\"todo-title\"\n          type=\"text\"\n          value={title}\n          onChange={(e) => setTitle(e.target.value)}\n          placeholder=\"What needs to be done?\"\n          className={cn(\n            'w-full px-4 py-2 border rounded-md shadow-sm',\n            'bg-gray-50 dark:bg-gray-700 border-gray-300 dark:border-gray-600',\n            'text-gray-900 dark:text-gray-100',\n            'focus:ring-primary-500 focus:border-primary-500',\n            errors.title && 'border-red-500'\n          )}\n          aria-invalid={!!errors.title}\n          aria-describedby={errors.title ? 'title-error' : undefined}\n          maxLength={200}\n        />\n        {errors.title && (\n          <p id=\"title-error\" className=\"text-red-500 text-sm mt-1\">\n            {errors.title}\n          </p>\n        )}\n      </div>\n\n      <div>\n        <label htmlFor=\"todo-dueDate\" className=\"sr-only\">\n          Due Date (optional)\n        </label>\n        <input\n          id=\"todo-dueDate\"\n          type=\"date\"\n          value={dueDate}\n          onChange={(e) => setDueDate(e.target.value)}\n          min={today}\n          className={cn(\n            'w-full sm:w-auto px-4 py-2 border rounded-md shadow-sm',\n            'bg-gray-50 dark:bg-gray-700 border-gray-300 dark:border-gray-600',\n            'text-gray-900 dark:text-gray-100',\n            'focus:ring-primary-500 focus:border-primary-500',\n            errors.dueDate && 'border-red-500'\n          )}\n          aria-invalid={!!errors.dueDate}\n          aria-describedby={errors.dueDate ? 'dueDate-error' : undefined}\n        />\n        {errors.dueDate && (\n          <p id=\"dueDate-error\" className=\"text-red-500 text-sm mt-1\">\n            {errors.dueDate}\n          </p>\n        )}\n      </div>\n\n      <button\n        type=\"submit\"\n        disabled={isSubmitting}\n        className={cn(\n          'flex items-center justify-center px-6 py-2 rounded-md font-semibold text-white',\n          'bg-primary-600 hover:bg-primary-700 transition-colors duration-200 shadow-md',\n          'focus:outline-none focus-visible:ring-2 focus-visible:ring-primary-500 focus-visible:ring-offset-2',\n          'disabled:opacity-60 disabled:cursor-not-allowed'\n        )}\n        aria-label=\"Add todo\"\n      >\n        {isSubmitting ? (\n          'Adding...'\n        ) : (\n          <>\n            <PlusIcon className=\"h-5 w-5 mr-2\" /> Add Todo\n          </>\n        )}\n      </button>\n    </form>\n  );\n}\n\n### FILE: components/TodoItem.tsx\n'use client';\n\nimport React, { useState, lazy, Suspense } from 'react';\nimport { Todo } from '@/types';\nimport { formatRelative, parseISO, isPast } from 'date-fns';\nimport { TrashIcon } from './Icons';\nimport { Modal } from './Modal';\nimport { LoadingSpinner } from './LoadingSpinner';\nimport { cn } from '@/lib/utils';\n\n// Lazy load TodoDetails component\nconst TodoDetails = lazy(() => import('./TodoDetails'));\n\ninterface TodoItemProps {\n  todo: Todo;\n  onUpdate: (id: string, updates: Partial<Todo>) => Promise<void>;\n  onDelete: (id: string) => Promise<void>;\n}\n\nexport function TodoItem({ todo, onUpdate, onDelete }: TodoItemProps) {\n  const [isDeleting, setIsDeleting] = useState(false);\n  const [isModalOpen, setIsModalOpen] = useState(false);\n\n  const handleToggleComplete = async () => {\n    await onUpdate(todo.id, { completed: !todo.completed });\n  };\n\n  const handleDelete = async () => {\n    if (window.confirm(`Are you sure you want to delete \"${todo.title}\"?`)) {\n      setIsDeleting(true);\n      await onDelete(todo.id);\n      setIsDeleting(false);\n    }\n  };\n\n  const formattedDueDate = todo.dueDate\n    ? formatRelative(parseISO(todo.dueDate), new Date())\n    : null;\n\n  const isOverdue = todo.dueDate && isPast(parseISO(todo.dueDate)) && !todo.completed;\n\n  return (\n    <li\n      className={cn(\n        'flex flex-col sm:flex-row items-start sm:items-center justify-between p-4 rounded-lg shadow-subtle transition-all duration-200',\n        'bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-700',\n        'hover:shadow-card hover:scale-[1.01]',\n        todo.completed && 'opacity-70 dark:opacity-60 line-through'\n      )}\n      aria-labelledby={`todo-title-${todo.id}`}\n      aria-describedby={`todo-status-${todo.id} todo-dueDate-${todo.id}`}\n    >\n      <div className=\"flex items-center flex-grow mb-2 sm:mb-0\">\n        <input\n          id={`checkbox-${todo.id}`}\n          type=\"checkbox\"\n          checked={todo.completed}\n          onChange={handleToggleComplete}\n          className={cn(\n            'h-5 w-5 rounded border-gray-300 dark:border-gray-600 text-primary-600',\n            'focus:ring-primary-500 focus:ring-offset-2 dark:focus:ring-offset-gray-800'\n          )}\n          aria-label={`Mark \"${todo.title}\" as ${todo.completed ? 'incomplete' : 'complete'}`}\n        />\n        <label\n          htmlFor={`checkbox-${todo.id}`}\n          id={`todo-title-${todo.id}`}\n          className={cn(\n            'ml-3 text-lg font-medium cursor-pointer',\n            'text-gray-900 dark:text-gray-100',\n            todo.completed && 'text-gray-500 dark:text-gray-400'\n          )}\n        >\n          {todo.title}\n        </label>\n      </div>\n\n      <div className=\"flex items-center space-x-3 text-sm text-gray-600 dark:text-gray-400\">\n        {formattedDueDate && (\n          <span\n            id={`todo-dueDate-${todo.id}`}\n            className={cn(\n              'px-2 py-1 rounded-full text-xs font-semibold',\n              isOverdue\n                ? 'bg-red-100 text-red-800 dark:bg-red-900 dark:text-red-200'\n                : 'bg-primary-100 text-primary-800 dark:bg-primary-900 dark:text-primary-200'\n            )}\n            aria-label={`Due date: ${formattedDueDate}`}\n          >\n            Due: {formattedDueDate}\n          </span>\n        )}\n\n        <button\n          onClick={() => setIsModalOpen(true)}\n          className=\"px-3 py-1 rounded-md text-primary-600 dark:text-primary-400 bg-primary-50 dark:bg-primary-900\n                     hover:bg-primary-100 dark:hover:bg-primary-800 transition-colors duration-200\n                     focus:outline-none focus-visible:ring-2 focus-visible:ring-primary-500 focus-visible:ring-offset-2\"\n          aria-label={`View details for \"${todo.title}\"`}\n        >\n          Details\n        </button>\n\n        <button\n          onClick={handleDelete}\n          disabled={isDeleting}\n          className={cn(\n            'p-2 rounded-md text-red-600 dark:text-red-400 bg-red-50 dark:bg-red-900',\n            'hover:bg-red-100 dark:hover:bg-red-800 transition-colors duration-200',\n            'focus:outline-none focus-visible:ring-2 focus-visible:ring-red-500 focus-visible:ring-offset-2',\n            'disabled:opacity-50 disabled:cursor-not-allowed'\n          )}\n          aria-label={`Delete \"${todo.title}\"`}\n        >\n          {isDeleting ? (\n            <LoadingSpinner className=\"h-5 w-5\" />\n          ) : (\n            <TrashIcon className=\"h-5 w-5\" />\n          )}\n        </button>\n      </div>\n\n      {/* Lazy loaded modal for details */}\n      <Modal isOpen={isModalOpen} onClose={() => setIsModalOpen(false)} title=\"Todo Details\">\n        <Suspense fallback={<LoadingSpinner className=\"py-8\" />}>\n          <TodoDetails todo={todo} />\n        </Suspense>\n      </Modal>\n    </li>\n  );\n}\n\n### FILE: components/TodoDetails.tsx\nimport React from 'react';\nimport { Todo } from '@/types';\nimport { format } from 'date-fns';\nimport { cn } from '@/lib/utils';\n\ninterface TodoDetailsProps {\n  todo: Todo;\n}\n\nconst TodoDetails: React.FC<TodoDetailsProps> = ({ todo }) => {\n  return (\n    <div className=\"space-y-4\">\n      <div>\n        <h3 className=\"text-lg font-semibold text-gray-800 dark:text-gray-200\">Title:</h3>\n        <p className=\"text-gray-700 dark:text-gray-300\">{todo.title}</p>\n      </div>\n      <div>\n        <h3 className=\"text-lg font-semibold text-gray-800 dark:text-gray-200\">Status:</h3>\n        <p\n          className={cn(\n            'font-medium',\n            todo.completed ? 'text-green-600 dark:text-green-400' : 'text-yellow-600 dark:text-yellow-400'\n          )}\n        >\n          {todo.completed ? 'Completed' : 'Active'}\n        </p>\n      </div>\n      {todo.dueDate && (\n        <div>\n          <h3 className=\"text-lg font-semibold text-gray-800 dark:text-gray-200\">Due Date:</h3>\n          <p className=\"text-gray-700 dark:text-gray-300\">\n            {format(new Date(todo.dueDate), 'PPP')} ({format(new Date(todo.dueDate), 'p')})\n          </p>\n        </div>\n      )}\n      <div>\n        <h3 className=\"text-lg font-semibold text-gray-800 dark:text-gray-200\">Created At:</h3>\n        <p className=\"text-gray-700 dark:text-gray-300\">\n          {format(new Date(todo.createdAt), 'PPP')} ({format(new Date(todo.createdAt), 'p')})\n        </p>\n      </div>\n      <div>\n        <h3 className=\"text-lg font-semibold text-gray-800 dark:text-gray-200\">Last Updated:</h3>\n        <p className=\"text-gray-700 dark:text-gray-300\">\n          {format(new Date(todo.updatedAt), 'PPP')} ({format(new Date(todo.updatedAt), 'p')})\n        </p>\n      </div>\n    </div>\n  );\n};\n\nexport default TodoDetails;\n\n### FILE: components/TodoList.tsx\nimport { Todo } from '@/types';\nimport { TodoItem } from './TodoItem';\n\ninterface TodoListProps {\n  todos: Todo[];\n  onUpdate: (id: string, updates: Partial<Todo>) => Promise<void>;\n  onDelete: (id: string) => Promise<void>;\n}\n\nexport function TodoList({ todos, onUpdate, onDelete }: TodoListProps) {\n  return (\n    <ul className=\"space-y-4 mt-8\" aria-label=\"Todo list\">\n      {todos.map((todo) => (\n        <TodoItem key={todo.id} todo={todo} onUpdate={onUpdate} onDelete={onDelete} />\n      ))}\n    </ul>\n  );\n}\n\n### FILE: hooks/useDarkMode.ts\n'use client';\n\nimport { useState, useEffect, useContext, createContext, useCallback } from 'react';\n\ninterface DarkModeContextType {\n  isDarkMode: boolean;\n  toggleDarkMode: () => void;\n}\n\nconst DarkModeContext = createContext<DarkModeContextType | undefined>(undefined);\n\nexport function DarkModeProvider({ children }: { children: React.ReactNode }) {\n  const [isDarkMode, setIsDarkMode] = useState(false);\n\n  // Effect to read initial preference from localStorage or system\n  useEffect(() => {\n    const storedPreference = localStorage.getItem('theme');\n    const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;\n\n    if (storedPreference === 'dark' || (storedPreference === null && prefersDark)) {\n      setIsDarkMode(true);\n      document.documentElement.classList.add('dark');\n    } else {\n      setIsDarkMode(false);\n      document.documentElement.classList.remove('dark');\n    }\n  }, []);\n\n  // Effect to update class on HTML element and localStorage\n  useEffect(() => {\n    if (isDarkMode) {\n      document.documentElement.classList.add('dark');\n      localStorage.setItem('theme', 'dark');\n    } else {\n      document.documentElement.classList.remove('dark');\n      localStorage.setItem('theme', 'light');\n    }\n  }, [isDarkMode]);\n\n  const toggleDarkMode = useCallback(() => {\n    setIsDarkMode((prevMode) => !prevMode);\n  }, []);\n\n  return (\n    <DarkModeContext.Provider value={{ isDarkMode, toggleDarkMode }}>\n      {children}\n    </DarkModeContext.Provider>\n  );\n}\n\nexport function useDarkMode() {\n  const context = useContext(DarkModeContext);\n  if (context === undefined) {\n    throw new Error('useDarkMode must be used within a DarkModeProvider');\n  }\n  return context;\n}\n\n### FILE: hooks/useTodos.ts\nimport { useState, useEffect, useCallback } from 'react';\nimport { Todo, TodoInput, TodoFilter } from '@/types';\nimport { api } from '@/lib/api';\nimport localforage from 'localforage';\n\ninterface UseTodosOptions {\n  filter: TodoFilter;\n  page: number;\n  limit: number;\n  searchQuery: string;\n}\n\nconst COMPLETED_TODOS_CACHE_KEY = 'completedTodosCache';\n\nexport function useTodos({ filter, page, limit, searchQuery }: UseTodosOptions) {\n  const [todos, setTodos] = useState<Todo[]>([]);\n  const [isLoading, setIsLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n  const [totalPages, setTotalPages] = useState(1);\n\n  const fetchTodos = useCallback(async () => {\n    setIsLoading(true);\n    setError(null);\n    try {\n      const params = new URLSearchParams({\n        page: page.toString(),\n        limit: limit.toString(),\n      });\n      if (filter !== 'all') {\n        params.append('filter', filter);\n      }\n      if (searchQuery) {\n        params.append('searchQuery', searchQuery);\n      }\n\n      const response = await api.get<{ todos: Todo[]; totalPages: number }>(`/api/todos?${params.toString()}`);\n      setTodos(response.todos);\n      setTotalPages(response.totalPages);\n\n      // Cache completed todos\n      const completed = response.todos.filter(t => t.completed);\n      if (completed.length > 0) {\n        await localforage.setItem(COMPLETED_TODOS_CACHE_KEY, completed);\n      }\n    } catch (err: any) {\n      console.error('Failed to fetch todos:', err);\n      setError(err.message || 'Failed to load todos.');\n      // Try to load from cache if fetching fails for completed todos\n      if (filter === 'completed') {\n        const cachedCompleted = await localforage.getItem<Todo[]>(COMPLETED_TODOS_CACHE_KEY);\n        if (cachedCompleted) {\n          setTodos(cachedCompleted);\n          setError('Failed to load latest todos, showing cached completed todos.');\n        }\n      }\n    } finally {\n      setIsLoading(false);\n    }\n  }, [filter, page, limit, searchQuery]);\n\n  useEffect(() => {\n    fetchTodos();\n  }, [fetchTodos]);\n\n  const addTodo = useCallback(async (todoInput: TodoInput) => {\n    try {\n      const newTodo = await api.post<Todo>('/api/todos', todoInput);\n      setTodos((prev) => (filter === 'completed' ? prev : [newTodo, ...prev])); // Only add if not on completed filter\n      // Re-fetch to ensure correct pagination/filtering if needed, or just update state\n      // For simplicity and immediate feedback, we'll update state directly if filter allows.\n      // A full re-fetch might be better for complex filtering/sorting.\n      fetchTodos();\n    } catch (err: any) {\n      console.error('Failed to add todo:', err);\n      throw new Error(err.message || 'Failed to add todo.');\n    }\n  }, [filter, fetchTodos]);\n\n  const updateTodo = useCallback(async (id: string, updates: Partial<Todo>) => {\n    try {\n      const updatedTodo = await api.put<Todo>(`/api/todos/${id}`, updates);\n      setTodos((prev) =>\n        prev\n          .map((todo) => (todo.id === id ? { ...todo, ...updatedTodo } : todo))\n          .filter((todo) => {\n            // If filter is 'active' and todo becomes completed, remove it\n            if (filter === 'active' && todo.id === id && todo.completed) return false;\n            // If filter is 'completed' and todo becomes active, remove it\n            if (filter === 'completed' && todo.id === id && !todo.completed) return false;\n            return true;\n          })\n      );\n      // Update cache for completed todos\n      if (updatedTodo.completed) {\n        const cachedCompleted = (await localforage.getItem<Todo[]>(COMPLETED_TODOS_CACHE_KEY)) || [];\n        const existingIndex = cachedCompleted.findIndex(t => t.id === updatedTodo.id);\n        if (existingIndex > -1) {\n          cachedCompleted[existingIndex] = updatedTodo;\n        } else {\n          cachedCompleted.push(updatedTodo);\n        }\n        await localforage.setItem(COMPLETED_TODOS_CACHE_KEY, cachedCompleted);\n      } else {\n        // If it's no longer completed, remove from cache\n        const cachedCompleted = (await localforage.getItem<Todo[]>(COMPLETED_TODOS_CACHE_KEY)) || [];\n        await localforage.setItem(COMPLETED_TODOS_CACHE_KEY, cachedCompleted.filter(t => t.id !== updatedTodo.id));\n      }\n    } catch (err: any) {\n      console.error('Failed to update todo:', err);\n      throw new Error(err.message || 'Failed to update todo.');\n    }\n  }, [filter]);\n\n  const deleteTodo = useCallback(async (id: string) => {\n    try {\n      await api.delete(`/api/todos/${id}`);\n      setTodos((prev) => prev.filter((todo) => todo.id !== id));\n      // Remove from completed cache if it was there\n      const cachedCompleted = (await localforage.getItem<Todo[]>(COMPLETED_TODOS_CACHE_KEY)) || [];\n      await localforage.setItem(COMPLETED_TODOS_CACHE_KEY, cachedCompleted.filter(t => t.id !== id));\n    } catch (err: any) {\n      console.error('Failed to delete todo:', err);\n      throw new Error(err.message || 'Failed to delete todo.');\n    }\n  }, []);\n\n  return {\n    todos,\n    isLoading,\n    error,\n    totalPages,\n    addTodo,\n    updateTodo,\n    deleteTodo,\n    fetchTodos, // Expose fetchTodos for manual refresh if needed\n  };\n}\n\n### FILE: lib/api.ts\ninterface RequestOptions extends RequestInit {\n  headers?: HeadersInit;\n}\n\nconst API_BASE_URL = process.env.NEXT_PUBLIC_API_BASE_URL || '';\n\nasync function request<T>(\n  method: string,\n  path: string,\n  data?: any,\n  options?: RequestOptions\n): Promise<T> {\n  const url = `${API_BASE_URL}${path}`;\n  const headers: HeadersInit = {\n    'Content-Type': 'application/json',\n    ...options?.headers,\n  };\n\n  const config: RequestInit = {\n    method,\n    headers,\n    ...options,\n  };\n\n  if (data) {\n    config.body = JSON.stringify(data);\n  }\n\n  try {\n    const response = await fetch(url, config);\n\n    if (!response.ok) {\n      let errorData: any = {};\n      try {\n        errorData = await response.json();\n      } catch (e) {\n        // If response is not JSON, use status text\n        errorData = { message: response.statusText };\n      }\n      throw new Error(errorData.message || `API Error: ${response.status}`);\n    }\n\n    // Handle 204 No Content\n    if (response.status === 204) {\n      return {} as T;\n    }\n\n    return await response.json();\n  } catch (error: any) {\n    console.error(`API Request Failed (${method} ${path}):`, error);\n    throw new Error(error.message || 'An unexpected error occurred.');\n  }\n}\n\nexport const api = {\n  get: <T>(path: string, options?: RequestOptions) => request<T>('GET', path, undefined, options),\n  post: <T>(path: string, data: any, options?: RequestOptions) =>\n    request<T>('POST', path, data, options),\n  put: <T>(path: string, data: any, options?: RequestOptions) =>\n    request<T>('PUT', path, data, options),\n  delete: <T>(path: string, options?: RequestOptions) =>\n    request<T>('DELETE', path, undefined, options),\n};\n\n### FILE: lib/dateUtils.ts\nimport { format, parseISO, isFuture, isToday } from 'date-fns';\n\n/**\n * Formats an ISO date string into a readable format.\n * @param isoDateString The date string in ISO format.\n * @param formatStr The format string (e.g., 'PPP', 'MM/dd/yyyy').\n * @returns Formatted date string or null if input is invalid.\n */\nexport function formatDate(isoDateString: string | null | undefined, formatStr: string = 'PPP'): string | null {\n  if (!isoDateString) return null;\n  try {\n    return format(parseISO(isoDateString), formatStr);\n  } catch (error) {\n    console.error('Error formatting date:', error);\n    return null;\n  }\n}\n\n/**\n * Validates if a given date string is today or in the future.\n * @param dateString The date string to validate (e.g., 'YYYY-MM-DD').\n * @returns True if the date is today or in the future, false otherwise.\n */\nexport function isValidDueDate(dateString: string | null | undefined): boolean {\n  if (!dateString) return true; // No due date is valid\n\n  try {\n    const date = parseISO(dateString);\n    // Check if it's a valid date object\n    if (isNaN(date.getTime())) {\n      return false;\n    }\n    return isToday(date) || isFuture(date);\n  } catch (error) {\n    console.error('Error validating due date:', error);\n    return false;\n  }\n}\n\n### FILE: lib/db.ts\nimport { promises as fs } from 'fs';\nimport path from 'path';\nimport { Todo } from '@/types';\nimport { isFuture, isToday, parseISO } from 'date-fns';\n\nconst DB_FILE = path.join(process.cwd(), 'data', 'todos.json');\n\n// Ensure the data directory exists\nasync function ensureDbFileExists() {\n  const dir = path.dirname(DB_FILE);\n  await fs.mkdir(dir, { recursive: true });\n  try {\n    await fs.access(DB_FILE);\n  } catch (error) {\n    await fs.writeFile(DB_FILE, JSON.stringify([]), 'utf8');\n  }\n}\n\n// Read todos from the file\nasync function readTodos(): Promise<Todo[]> {\n  await ensureDbFileExists();\n  const data = await fs.readFile(DB_FILE, 'utf8');\n  return JSON.parse(data);\n}\n\n// Write todos to the file\nasync function writeTodos(todos: Todo[]): Promise<void> {\n  await fs.writeFile(DB_FILE, JSON.stringify(todos, null, 2), 'utf8');\n}\n\ninterface GetTodosOptions {\n  filter?: 'all' | 'active' | 'completed' | null;\n  page?: number;\n  limit?: number;\n  searchQuery?: string;\n}\n\nexport async function getTodos({\n  filter = 'all',\n  page = 1,\n  limit = 50,\n  searchQuery = '',\n}: GetTodosOptions): Promise<{ todos: Todo[]; totalPages: number }> {\n  let allTodos = await readTodos();\n\n  // Filter out soft-deleted todos\n  allTodos = allTodos.filter((todo) => todo.deletedAt === null);\n\n  // Apply search query\n  if (searchQuery) {\n    const lowerCaseQuery = searchQuery.toLowerCase();\n    allTodos = allTodos.filter((todo) =>\n      todo.title.toLowerCase().includes(lowerCaseQuery)\n    );\n  }\n\n  // Apply status filter\n  let filteredTodos = allTodos;\n  if (filter === 'active') {\n    filteredTodos = allTodos.filter((todo) => !todo.completed);\n  } else if (filter === 'completed') {\n    filteredTodos = allTodos.filter((todo) => todo.completed);\n  }\n\n  // Sort by createdAt descending (newest first)\n  filteredTodos.sort((a, b) => parseISO(b.createdAt).getTime() - parseISO(a.createdAt).getTime());\n\n  // Pagination\n  const totalItems = filteredTodos.length;\n  const totalPages = Math.ceil(totalItems / limit);\n  const startIndex = (page - 1) * limit;\n  const endIndex = startIndex + limit;\n  const paginatedTodos = filteredTodos.slice(startIndex, endIndex);\n\n  return { todos: paginatedTodos, totalPages };\n}\n\nexport async function addTodo(newTodo: Todo): Promise<Todo> {\n  const todos = await readTodos();\n  todos.push(newTodo);\n  await writeTodos(todos);\n  return newTodo;\n}\n\nexport async function updateTodo(id: string, updates: Partial<Todo>): Promise<Todo | null> {\n  const todos = await readTodos();\n  const index = todos.findIndex((todo) => todo.id === id && todo.deletedAt === null);\n\n  if (index === -1) {\n    return null;\n  }\n\n  const updatedTodo = {\n    ...todos[index],\n    ...updates,\n    updatedAt: new Date().toISOString(),\n  };\n\n  // Ensure dueDate validation on update if it's being changed\n  if (updates.dueDate) {\n    const dueDate = parseISO(updates.dueDate);\n    if (!isToday(dueDate) && !isFuture(dueDate)) {\n      throw new Error('Due date must be today or in the future.');\n    }\n  }\n\n  todos[index] = updatedTodo;\n  await writeTodos(todos);\n  return updatedTodo;\n}\n\nexport async function deleteTodoSoft(id: string): Promise<Todo | null> {\n  const todos = await readTodos();\n  const index = todos.findIndex((todo) => todo.id === id && todo.deletedAt === null);\n\n  if (index === -1) {\n    return null;\n  }\n\n  const deletedTodo = {\n    ...todos[index],\n    deletedAt: new Date().toISOString(),\n    updatedAt: new Date().toISOString(),\n  };\n\n  todos[index] = deletedTodo;\n  await writeTodos(todos);\n  return deletedTodo;\n}\n\n### FILE: lib/utils.ts\nimport { type ClassValue, clsx } from 'clsx';\nimport { twMerge } from 'tailwind-merge';\n\nexport function cn(...inputs: ClassValue[]) {\n  return twMerge(clsx(inputs));\n}\n\n### FILE: lib/validation.ts\nimport { z } from 'zod';\nimport { isFuture, isToday, parseISO } from 'date-fns';\n\n// Custom validation for due date\nconst dueDateValidation = z.string().datetime({ offset: true }).optional().nullable().refine(\n  (dateString) => {\n    if (!dateString) return true; // Null or undefined due date is allowed\n    const date = parseISO(dateString);\n    // Check if it's a valid date object and is today or in the future\n    return !isNaN(date.getTime()) && (isToday(date) || isFuture(date));\n  },\n  {\n    message: 'Due date must be today or in the future.',\n  }\n);\n\n// Schema for creating a new todo (frontend input)\nexport const todoInputSchema = z.object({\n  title: z\n    .string()\n    .trim()\n    .min(1, { message: 'Title cannot be empty.' })\n    .max(200, { message: 'Title cannot exceed 200 characters.' }),\n  dueDate: z.string().optional().nullable().transform(e => e === \"\" ? null : e), // Convert empty string to null\n});\n\n// Schema for API POST request (backend validation)\nexport const todoSchema = z.object({\n  title: z\n    .string()\n    .trim()\n    .min(1, { message: 'Title cannot be empty.' })\n    .max(200, { message: 'Title cannot exceed 200 characters.' }),\n  dueDate: dueDateValidation,\n});\n\n// Schema for updating a todo (API PUT request)\nexport const updateTodoSchema = z.object({\n  title: z\n    .string()\n    .trim()\n    .min(1, { message: 'Title cannot be empty.' })\n    .max(200, { message: 'Title cannot exceed 200 characters.' })\n    .optional(),\n  completed: z.boolean().optional(),\n  dueDate: dueDateValidation.optional(),\n});\n\n// Type for frontend form input\nexport type TodoInput = z.infer<typeof todoInputSchema>;\n\n### FILE: types.ts\nexport type TodoFilter = 'all' | 'active' | 'completed';\n\nexport interface Todo {\n  id: string;\n  title: string;\n  completed: boolean;\n  dueDate: string | null; // ISO string\n  createdAt: string; // ISO string\n  updatedAt: string; // ISO string\n  deletedAt: string | null; // ISO string for soft delete\n  userId: string; // For future multi-user support, currently hardcoded\n}\n\nexport interface TodoInput {\n  title: string;\n  dueDate?: string | null; // Optional for creation\n}\n\n### FILE: data/todos.json\n[]"
}