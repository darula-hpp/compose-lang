{
  "04d10c378dd289addfca5684c05f8cea6bdb31edc2d8ea2d4fead93c3247adf7": "import React from 'react';\n\n/**\n * Home Page Component\n * Description: Main todo list page.\n * This component serves as the entry point for the application's main functionality,\n * typically displaying a list of todos and providing options to manage them.\n * It is not protected, meaning it can be accessed without authentication.\n */\nconst Home = () => {\n  // State management for todos would typically go here.\n  // For example: const [todos, setTodos] = React.useState([]);\n\n  // Effects for data fetching or side effects would go here.\n  // For example:\n  // React.useEffect(() => {\n  //   // Simulate fetching todos from an API\n  //   const fetchTodos = async () => {\n  //     try {\n  //       // In a real application, replace with an actual API call\n  //       const response = await new Promise(resolve => setTimeout(() => resolve([\n  //         { id: 1, text: 'Learn React', completed: true },\n  //         { id: 2, text: 'Build a Todo App', completed: false },\n  //         { id: 3, text: 'Deploy to Production', completed: false },\n  //       ]), 500));\n  //       setTodos(response);\n  //     } catch (error) {\n  //       console.error(\"Failed to fetch todos:\", error);\n  //       // Implement user-facing error handling here (e.g., show a toast message)\n  //     }\n  //   };\n  //   fetchTodos();\n  // }, []); // Empty dependency array means this effect runs once after the initial render\n\n  return (\n    <div className=\"home-page\">\n      {/* Main heading for the page */}\n      <h1>Welcome to Your Todo List</h1>\n\n      {/* A brief description or introductory message */}\n      <p>\n        This is your main dashboard for managing all your tasks.\n        Get organized and boost your productivity!\n      </p>\n\n      {/* Placeholder for where the todo list or other main content would be rendered */}\n      <section className=\"todo-list-section\">\n        <h2>Your Tasks</h2>\n        {/*\n          In a real application, you would render a list of todos here,\n          potentially using a dedicated TodoList component.\n          Example:\n          {todos.length === 0 ? (\n            <p>No tasks yet! Add a new one to get started.</p>\n          ) : (\n            <ul>\n              {todos.map(todo => (\n                <li key={todo.id} style={{ textDecoration: todo.completed ? 'line-through' : 'none' }}>\n                  {todo.text}\n                </li>\n              ))}\n            </ul>\n          )}\n        */}\n        <p>\n          <em>(Todo list functionality will be implemented here.)</em>\n        </p>\n        {/* Example of a button to add a new todo */}\n        <button\n          onClick={() => {\n            // Handle adding a new todo\n            console.log('Add new todo clicked');\n            // In a real app, this might open a modal or navigate to a new page\n          }}\n          style={{ padding: '10px 20px', cursor: 'pointer' }}\n        >\n          Add New Task\n        </button>\n      </section>\n\n      {/* Optional: Footer or additional navigation */}\n      <footer style={{ marginTop: '40px', fontSize: '0.9em', color: '#666' }}>\n        <p>&copy; {new Date().getFullYear()} My Todo App. All rights reserved.</p>\n      </footer>\n    </div>\n  );\n};\n\nexport default Home;",
  "fcba8051b2b1450bf1e377731c7c57fca2c41b6a72c87b1762180776c7cbcde0": "import React from 'react';\nimport PropTypes from 'prop-types';\n\n/**\n * TodoItem component displays a single todo item with a checkbox to toggle its completion status\n * and a button to delete it.\n *\n * @param {object} props - The component's props.\n * @param {object} props.todo - The todo object containing id, text, and completed status.\n * @param {function(string | number): void} [props.onToggleComplete] - Callback function to toggle the completion status of a todo.\n * @param {function(string | number): void} [props.onDelete] - Callback function to delete a todo.\n */\nconst TodoItem = ({ todo, onToggleComplete, onDelete }) => {\n  // Destructure properties from the todo object for easier access\n  const { id, text, completed } = todo;\n\n  /**\n   * Handles the change event of the checkbox.\n   * Calls the onToggleComplete prop with the todo's id.\n   */\n  const handleToggle = () => {\n    // Ensure onToggleComplete is a function before calling it\n    if (typeof onToggleComplete === 'function') {\n      onToggleComplete(id);\n    }\n  };\n\n  /**\n   * Handles the click event of the delete button.\n   * Calls the onDelete prop with the todo's id.\n   */\n  const handleDelete = () => {\n    // Ensure onDelete is a function before calling it\n    if (typeof onDelete === 'function') {\n      onDelete(id);\n    }\n  };\n\n  return (\n    <div\n      style={{\n        display: 'flex',\n        alignItems: 'center',\n        padding: '10px',\n        borderBottom: '1px solid #eee',\n        backgroundColor: completed ? '#f9f9f9' : '#ffffff',\n      }}\n    >\n      {/* Checkbox to mark todo as complete or incomplete */}\n      <input\n        type=\"checkbox\"\n        checked={completed}\n        onChange={handleToggle}\n        style={{ marginRight: '10px', cursor: 'pointer' }}\n        aria-label={`Mark \"${text}\" as ${completed ? 'incomplete' : 'complete'}`}\n      />\n\n      {/* Display the todo text, applying line-through style if completed */}\n      <span\n        style={{\n          flexGrow: 1, // Allows the text to take up available space\n          textDecoration: completed ? 'line-through' : 'none',\n          color: completed ? '#888' : '#333',\n          fontSize: '16px',\n        }}\n      >\n        {text}\n      </span>\n\n      {/* Button to delete the todo item */}\n      <button\n        onClick={handleDelete}\n        style={{\n          marginLeft: '10px',\n          padding: '6px 12px',\n          backgroundColor: '#dc3545', // Bootstrap 'danger' color\n          color: 'white',\n          border: 'none',\n          borderRadius: '4px',\n          cursor: 'pointer',\n          fontSize: '14px',\n          transition: 'background-color 0.2s ease',\n        }}\n        // Add hover effect for better user experience\n        onMouseOver={(e) => (e.currentTarget.style.backgroundColor = '#c82333')}\n        onMouseOut={(e) => (e.currentTarget.style.backgroundColor = '#dc3545')}\n        aria-label={`Delete \"${text}\"`}\n      >\n        Delete\n      </button>\n    </div>\n  );\n};\n\n// Prop validation for the TodoItem component to ensure correct prop types and required props\nTodoItem.propTypes = {\n  /**\n   * The todo object to be displayed.\n   * It must contain an `id`, `text`, and `completed` status.\n   */\n  todo: PropTypes.shape({\n    id: PropTypes.oneOfType([PropTypes.string, PropTypes.number]).isRequired,\n    text: PropTypes.string.isRequired,\n    completed: PropTypes.bool.isRequired,\n  }).isRequired,\n  /**\n   * Callback function triggered when the checkbox is toggled.\n   * It receives the `id` of the todo as an argument.\n   */\n  onToggleComplete: PropTypes.func,\n  /**\n   * Callback function triggered when the delete button is clicked.\n   * It receives the `id` of the todo as an argument.\n   */\n  onDelete: PropTypes.func,\n};\n\n// Default props to provide fallback functions for optional callbacks,\n// preventing errors if they are not passed by the parent component.\nTodoItem.defaultProps = {\n  onToggleComplete: () => {}, // No-op function\n  onDelete: () => {}, // No-op function\n};\n\nexport default TodoItem;",
  "398e53cb17f7ac63ac354ba4b816e0c61dcdf068bdf12719d0aaa2eddddfd13b": "import React, { useState } from 'react';\n// No PropTypes needed as the component does not accept any props.\n\n/**\n * TodoForm Component\n * A functional component that provides a form to add new todo items.\n * It manages its own input state and handles form submission.\n */\nfunction TodoForm() {\n  // State to hold the current value of the todo input field.\n  // Initialized as an empty string.\n  const [todoText, setTodoText] = useState('');\n\n  /**\n   * Handles changes to the input field.\n   * Updates the `todoText` state with the current value of the input.\n   * @param {Object} event - The change event object from the input element.\n   */\n  const handleChange = (event) => {\n    setTodoText(event.target.value);\n  };\n\n  /**\n   * Handles the form submission.\n   * Prevents the default form submission behavior (page reload).\n   * Validates the input, logs the todo text, and clears the input field.\n   * In a real application, this would typically send the todo to a parent component\n   * or a global state management system (e.g., Redux, Context API) to be added to a list.\n   * @param {Object} event - The submit event object from the form element.\n   */\n  const handleSubmit = (event) => {\n    // Prevent the default form submission behavior which causes a page reload.\n    event.preventDefault();\n\n    // Basic validation: Check if the input field is not empty or just whitespace.\n    if (todoText.trim() === '') {\n      // Optionally, display an error message to the user.\n      // For now, we'll just log to the console.\n      console.error('Todo text cannot be empty.');\n      return; // Stop the submission if validation fails.\n    }\n\n    // In a production application, you would typically pass this `todoText`\n    // to a parent component via a prop function (e.g., `onAddTodo(todoText)`).\n    // For this example, we'll just log it to the console.\n    console.log('New Todo Added:', todoText);\n\n    // Clear the input field after successful submission.\n    setTodoText('');\n  };\n\n  return (\n    // The form element handles the submission.\n    <form onSubmit={handleSubmit}>\n      {/* Label for accessibility, linked to the input by its id. */}\n      <label htmlFor=\"todo-input\">\n        Add New Todo:\n      </label>\n      {/* Input field for the todo text. */}\n      <input\n        id=\"todo-input\" // Unique ID for the input, linked to the label.\n        type=\"text\"\n        value={todoText} // Controlled component: input value is tied to state.\n        onChange={handleChange} // Update state on every input change.\n        placeholder=\"What needs to be done?\" // Helpful placeholder text.\n        aria-label=\"New todo item\" // Accessibility label for screen readers.\n      />\n      {/* Button to submit the form. */}\n      <button type=\"submit\">\n        Add Todo\n      </button>\n    </form>\n  );\n}\n\nexport default TodoForm;",
  "15a11a160bec268d806f27237b655e45252fa18a8f0ff3a1a4b9783cd88451b6": "const express = require('express');\nconst router = express.Router();\n\n/**\n * @route GET /api/todos\n * @description Fetch all todos from the database.\n * @access Public\n * @returns {object} 200 - An array of todo objects.\n * @returns {object} 400 - If invalid query parameters are provided.\n * @returns {object} 500 - If a server error occurs.\n */\nrouter.get('/todos', async (req, res) => {\n    try {\n        // Input Validation: For a simple 'fetch all' endpoint,\n        // we typically don't expect query parameters unless for filtering or pagination.\n        // If no such functionality is intended, reject unexpected query parameters.\n        if (Object.keys(req.query).length > 0) {\n            return res.status(400).json({\n                success: false,\n                message: 'Invalid query parameters. This endpoint does not support query parameters for fetching all todos.'\n            });\n        }\n\n        // --- Simulate database call to fetch all todos ---\n        // In a real application, this would involve calling a service or repository layer\n        // that interacts with your database (e.g., Mongoose, Sequelize, Knex, etc.).\n        // Example: const todos = await todoService.findAll();\n        const todos = [\n            { id: '1', title: 'Learn Express', completed: false, createdAt: new Date() },\n            { id: '2', title: 'Build API', completed: true, createdAt: new Date() },\n            { id: '3', title: 'Deploy App', completed: false, createdAt: new Date() }\n        ];\n        // --- End simulation ---\n\n        // If no todos are found, it's still a successful operation, just an empty list.\n        // A 200 OK with an empty array is standard practice for 'fetch all'.\n        if (!todos || todos.length === 0) {\n            return res.status(200).json({\n                success: true,\n                message: 'No todos found.',\n                data: []\n            });\n        }\n\n        // Respond with the fetched todos\n        res.status(200).json({\n            success: true,\n            message: 'Todos fetched successfully.',\n            data: todos\n        });\n\n    } catch (error) {\n        // Log the error for debugging purposes. In a production environment,\n        // use a dedicated logging library (e.g., Winston, Pino) and avoid\n        // exposing raw error details to the client.\n        console.error('Error fetching todos:', error);\n\n        // Send a 500 Internal Server Error response\n        res.status(500).json({\n            success: false,\n            message: 'Failed to fetch todos due to a server error.',\n            // In production, consider a generic error message like:\n            // 'An unexpected error occurred. Please try again later.'\n            error: process.env.NODE_ENV === 'development' ? error.message : 'Internal Server Error'\n        });\n    }\n});\n\nmodule.exports = router;",
  "489e9ae9637c51e0838b5802216bd110b4bf27e4b79b6238b6ec3117db40fceb": "const express = require('express');\nconst router = express.Router();\n\n/**\n * @route POST /\n * @description Create a new todo item.\n * @access Public\n * @body {string} title - The title of the todo item. (Required)\n * @body {string} [description] - An optional description for the todo item.\n * @returns {object} 201 - The newly created todo item.\n * @returns {object} 400 - Bad Request if input validation fails.\n * @returns {object} 500 - Internal Server Error if an unexpected error occurs.\n */\nrouter.post('/', (req, res) => {\n    try {\n        const { title, description } = req.body;\n\n        // 1. Input Validation\n        // Ensure title is provided, is a string, and is not empty.\n        if (!title || typeof title !== 'string' || title.trim().length === 0) {\n            return res.status(400).json({ message: 'Title is required and must be a non-empty string.' });\n        }\n\n        // If description is provided, ensure it is a string.\n        if (description !== undefined && typeof description !== 'string') {\n            return res.status(400).json({ message: 'Description must be a string if provided.' });\n        }\n\n        // 2. Business Logic Placeholder\n        // In a real application, you would interact with a database here\n        // to save the new todo item. For this example, we'll simulate it.\n\n        // Generate a unique ID (in a real app, this would come from the database)\n        const newTodoId = Math.floor(Math.random() * 1000000) + 1;\n\n        const newTodo = {\n            id: newTodoId,\n            title: title.trim(),\n            description: description ? description.trim() : '',\n            completed: false, // New todos are typically not completed by default\n            createdAt: new Date().toISOString() // Timestamp for creation\n        };\n\n        // Log the creation for demonstration purposes (remove in production or use a proper logger)\n        console.log('New todo created:', newTodo);\n\n        // 3. Send Success Response\n        // According to REST best practices, a POST request that successfully creates\n        // a resource should return a 201 Created status code and the newly created resource.\n        res.status(201).json(newTodo);\n\n    } catch (error) {\n        // 4. Error Handling\n        // Log the error for debugging purposes.\n        console.error('Error creating todo item:', error);\n\n        // Send a 500 Internal Server Error response for unexpected errors.\n        res.status(500).json({ message: 'An unexpected error occurred while creating the todo item.', error: error.message });\n    }\n});\n\nmodule.exports = router;",
  "c2ec3b17944ac83e0f1dc18eadec237ba5757f05cea5147768217b1d48d58b18": "const express = require('express');\nconst router = express.Router();\n\n// --- Mock Database (for demonstration purposes) ---\n// In a real application, this would be replaced with a database interaction (e.g., Mongoose, Sequelize, Prisma).\n// For production, consider a dedicated data access layer.\nconst todos = [\n    { id: 1, title: 'Learn Node.js', completed: false },\n    { id: 2, title: 'Build an Express API', completed: true },\n    { id: 3, title: 'Deploy to production', completed: false },\n];\n\n/**\n * PATCH /todos/:todoId/toggle\n * Description: Toggles the 'completed' status of a specific todo item.\n *\n * This endpoint expects a todo ID in the URL path. It will find the todo\n * by its ID and flip its 'completed' status (true to false, or false to true).\n *\n * @param {object} req - The Express request object.\n * @param {object} res - The Express response object.\n * @returns {Promise<void>} - A promise that resolves when the response is sent.\n */\nrouter.patch('/todos/:todoId/toggle', async (req, res) => {\n    try {\n        // 1. Input Validation: Extract and validate todoId from path parameters.\n        // Ensure todoId is a valid positive integer.\n        const todoId = parseInt(req.params.todoId, 10);\n\n        if (isNaN(todoId) || todoId <= 0) {\n            // Respond with 400 Bad Request if todoId is not a valid positive integer.\n            return res.status(400).json({\n                message: 'Invalid todo ID provided. ID must be a positive number.',\n                code: 'INVALID_TODO_ID'\n            });\n        }\n\n        // 2. Business Logic: Find the todo item in the mock database.\n        // In a real application, this would involve a database query (e.g., `Todo.findById(todoId)`).\n        const todoIndex = todos.findIndex(todo => todo.id === todoId);\n\n        // If todo not found, return 404 Not Found.\n        if (todoIndex === -1) {\n            return res.status(404).json({\n                message: `Todo with ID ${todoId} not found.`,\n                code: 'TODO_NOT_FOUND'\n            });\n        }\n\n        // 3. Update Data: Toggle the 'completed' status of the found todo.\n        // In a real application, this would be a database update operation.\n        todos[todoIndex].completed = !todos[todoIndex].completed;\n\n        // Create a copy of the updated todo to return. This is good practice\n        // to avoid returning direct references to internal data structures,\n        // especially if they might be modified elsewhere.\n        const updatedTodo = { ...todos[todoIndex] };\n\n        // 4. Respond: Send a success response (200 OK) with the updated todo item.\n        res.status(200).json({\n            message: 'Todo status toggled successfully.',\n            data: updatedTodo\n        });\n\n    } catch (error) {\n        // 5. Error Handling: Catch any unexpected server-side errors.\n        // Log the error for debugging purposes without exposing sensitive details to the client.\n        console.error(`[ToggleTodo API] Error processing request for todo ID ${req.params.todoId}:`, error);\n        res.status(500).json({\n            message: 'An unexpected server error occurred while toggling todo status.',\n            code: 'INTERNAL_SERVER_ERROR'\n        });\n    }\n});\n\nmodule.exports = router;",
  "095077d3ab0ee21e8ef373ff837c2d650bb55eba9a414292fbda9013ac1b4a69": "const express = require('express');\nconst router = express.Router();\n\n// In a real application, this would be a database model or service.\n// For demonstration, we'll use a simple in-memory array to simulate data.\n// This array persists across requests as it's defined outside the route handler.\nlet todos = [\n    { id: 1, title: 'Learn Node.js', completed: false },\n    { id: 2, title: 'Build an Express API', completed: false },\n    { id: 3, title: 'Deploy to production', completed: false },\n];\n\n/**\n * DELETE /todos/:id\n * Description: Delete a todo by ID\n */\nrouter.delete('/todos/:id', async (req, res) => {\n    try {\n        // Extract the todo ID from the request parameters\n        const { id } = req.params;\n\n        // --- Input Validation ---\n        // Check if the ID is provided in the URL path.\n        // While Express routing typically handles this, it's a good defensive check.\n        if (!id) {\n            return res.status(400).json({ message: 'Todo ID is required in the URL path.' });\n        }\n\n        // Validate if the ID is a valid number.\n        // For applications using UUIDs, a regex validation would be used instead of parseInt.\n        const todoId = parseInt(id, 10);\n        if (isNaN(todoId)) {\n            return res.status(400).json({ message: 'Invalid Todo ID format. Must be a number.' });\n        }\n\n        // --- Simulate Database Operation ---\n        // In a production application, this would involve an asynchronous call\n        // to a database (e.g., `await TodoModel.findByIdAndDelete(todoId);`).\n        // For this example, we're manipulating an in-memory array.\n\n        // Find the index of the todo item in our in-memory array\n        const todoIndex = todos.findIndex(todo => todo.id === todoId);\n\n        // If the todo item is not found, return a 404 Not Found response\n        if (todoIndex === -1) {\n            return res.status(404).json({ message: `Todo with ID ${todoId} not found.` });\n        }\n\n        // Remove the todo item from the array using its index\n        todos.splice(todoIndex, 1);\n\n        // --- Success Response ---\n        // Respond with 204 No Content. This status code is standard for successful\n        // DELETE requests where no content is returned in the response body.\n        res.status(204).send();\n\n    } catch (error) {\n        // --- Error Handling ---\n        // Log the error for server-side debugging. In production, use a robust logger.\n        console.error(`Error deleting todo with ID ${req.params.id}:`, error);\n\n        // Send a 500 Internal Server Error response to the client.\n        // Avoid exposing sensitive error details in production environments.\n        res.status(500).json({\n            message: 'An unexpected error occurred while deleting the todo.',\n            error: process.env.NODE_ENV === 'production' ? undefined : error.message // Only expose error message in non-production\n        });\n    }\n});\n\nmodule.exports = router;"
}